import _Object$defineProperty from '@babel/runtime-corejs2/core-js/object/define-property';
import _Object$defineProperties from '@babel/runtime-corejs2/core-js/object/define-properties';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs2/core-js/object/get-own-property-descriptors';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs2/core-js/object/get-own-property-descriptor';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs2/core-js/object/get-own-property-symbols';
import _Object$keys from '@babel/runtime-corejs2/core-js/object/keys';
import _defineProperty from '@babel/runtime-corejs2/helpers/defineProperty';
import stringify from 'fast-json-stable-stringify';
import sha256 from 'fast-sha256';
import nacl from 'tweetnacl';
import _Array$isArray from '@babel/runtime-corejs2/core-js/array/is-array';
import _Promise from '@babel/runtime-corejs2/core-js/promise';
import bs58 from 'bs58';
import { Buffer as Buffer$1 } from 'buffer';
import _extends from '@babel/runtime-corejs2/helpers/extends';
import _JSON$stringify from '@babel/runtime-corejs2/core-js/json/stringify';
import axios from 'axios';
import _Date$now from '@babel/runtime-corejs2/core-js/date/now';
import base64js from 'base64-js';

var signatureScheme = "Token-Ed25519-SHA512";
var urls = {
	local: "http://localhost:8000",
	dev: "https://api.dev.token.io",
	stg: "https://api.stg.token.io",
	perf: "https://api.perf.token.io",
	sandbox: "https://api.sandbox.token.io",
	int: "https://api.int.token.io",
	prd: "https://api.token.io"
};
var webAppUrls = {
	local: "http://localhost:5000",
	dev: "https://web-app.dev.token.io",
	stg: "https://web-app.stg.token.io",
	perf: "https://web-app.perf.token.io",
	sandbox: "https://web-app.sandbox.token.io",
	int: "https://web-app.int.token.io",
	prd: "https://web-app.token.io"
};
var transferTokenVersion = "1.0";
var accessTokenVersion = "1.0";
var defaultCurrency = "EUR";
var decimalPrecision = 4;
var corsDomainSuffix = ".token.io";
var KeyLevel = {
	PRIVILEGED: "PRIVILEGED",
	STANDARD: "STANDARD",
	LOW: "LOW"
};
var lowKeyExpiration = 1209600000;
var devKey = {
	"default": "f3982819-5d8d-4123-9601-886df2780f42",
	local: "f3982819-5d8d-4123-9601-886df2780f42",
	dev: "f3982819-5d8d-4123-9601-886df2780f42",
	stg: "f3982819-5d8d-4123-9601-886df2780f42",
	sandbox: "f3982819-5d8d-4123-9601-886df2780f42",
	int: "f3982819-5d8d-4123-9601-886df2780f42",
	prd: "f3982819-5d8d-4123-9601-886df2780f42"
};
var config = {
	signatureScheme: signatureScheme,
	urls: urls,
	webAppUrls: webAppUrls,
	transferTokenVersion: transferTokenVersion,
	accessTokenVersion: accessTokenVersion,
	defaultCurrency: defaultCurrency,
	decimalPrecision: decimalPrecision,
	corsDomainSuffix: corsDomainSuffix,
	KeyLevel: KeyLevel,
	lowKeyExpiration: lowKeyExpiration,
	devKey: devKey
};

/**
 * Converts an input buffer or input string to UTF8 encoded Base64Url.
 *
 * @param {String|Buffer} input input string or buffer
 * @return {String} encoded output
 */
const base64Url = input => {
  if (Buffer.isBuffer(input)) {
    return base64ToBase64Url(input.toString('base64'));
  }

  return base64ToBase64Url(Buffer.from(input, 'utf8').toString('base64'));
};
/**
 * Converts a UTF8 encoded base64url string to a Buffer.
 *
 * @param {String} input input string
 * @return {Buffer} buffer output
 */

const base64UrlToBuffer = input => {
  return Buffer.from(base64UrlToBase64(input), 'base64');
};

function base64ToBase64Url(input) {
  return input.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}

function base64UrlToBase64(input) {
  return pad(input.toString()).replace(/-/g, '+').replace(/_/g, '/');
}

function pad(input) {
  const segmentLength = 4;
  const stringLength = input.length;
  const diff = stringLength % segmentLength;

  if (!diff) {
    return input;
  }

  let position = stringLength;
  let padLength = segmentLength - diff;
  const paddedStringLength = stringLength + padLength;
  const buffer = Buffer.alloc(paddedStringLength);
  buffer.write(input);

  while (padLength--) {
    buffer.write('=', position++);
  }

  return buffer.toString();
}

/**
 * Class to provide static utility functions.
 */

class Util {
  /**
   * Generates a random nonce
   *
   * @return {string} random string
   */
  static generateNonce() {
    return Math.random().toString(36).slice(-9) + Math.random().toString(36).slice(-9);
  }
  /**
   * Generates a random alias. Handy for tests.
   *
   * @return {Object} alias protobuf
   */


  static randomAlias(type = 'EMAIL') {
    if (type === 'DOMAIN') {
      return {
        type,
        value: Util.generateNonce() + '.com.noveirfy'
      };
    }

    return {
      type: 'EMAIL',
      value: 'test-' + Util.generateNonce() + '+noverify@example.com'
    };
  }
  /**
   * Returns the token alias.
   *
   * @return {Object} token alias protobuf
   */


  static tokenAlias() {
    return {
      type: 'DOMAIN',
      value: 'token.io',
      realm: 'token'
    };
  }
  /**
   * Tests if a string ends with a suffix,
   *
   * @param {string} str - the string to test
   * @param {string} suffix - the suffix to test
   * @return {boolean} true if it does
   */


  static stringEndsWith(str, suffix) {
    if (str === null || str === '' || suffix === null || suffix === '') {
      return false;
    }

    str = str.toString();
    suffix = suffix.toString();
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  }
  /**
   * Gets the specified byte of the 4 byte word, according to index. Assumes 2s complement
   * representation of the word
   *
   * @param {number} word - 32 bit value number, in 2s complement
   * @param {number} index - index of the byte to return
   * @return {number} the desired byte [0, 255]
   */


  static getByte(word, index) {
    if (index === 0) {
      return word & (1 << 8) - 1;
    } else if (index === 1) {
      return (word & (1 << 16) - 1) >> 8;
    } else if (index === 2) {
      return (word & (1 << 24) - 1) >> 16;
    }

    const temp = (word & (1 << 8) - 1 << 24) >> 24;
    return temp < 0 ? 256 + temp : temp;
  }
  /**
   * Count the number of decimal points in a number
   *
   * @param {Number} value - number
   * @return {Number} number of decimals
   */


  static countDecimals(value) {
    if (Math.floor(value) == value) {
      return 0;
    }

    return value.toString().split('.')[1].length || 0;
  }
  /**
   * Helper method to handle promise exceptions. The function will be executed, and if
   * anything fails, a rejected promise is returned, with the method name that failed,
   * included in the rejection.
   *
   * @param {function} method - outside method that is being executed
   * @param {function} fn - function to try to execute
   * @return {Promise} successful or rejected promise
   */


  static async callAsync(method, fn) {
    try {
      return await fn();
    } catch (err) {
      const reason = err.response !== undefined && err.response.data !== undefined ? err.response.data : 'UNKNOWN';
      err.message = method.name + ': ' + err.message + '. Reason: ' + reason;
      return _Promise.reject(err);
    }
  }
  /**
   * Helper method similar to the one above, but without promises
   *
   * @param {function} method - outside method that is being executed
   * @param {function} fn - function to try to execute
   * @return {Object} successful result or thrown error
   */


  static callSync(method, fn) {
    try {
      return fn();
    } catch (err) {
      const reason = err.response !== undefined && err.response.data !== undefined ? err.response.data : 'UNKNOWN';
      err.message = method.name + ': ' + err.message + '. Reason: ' + reason;
      throw err;
    }
  }
  /**
   * Support alias hashing
   *
   * @param {Object} alias - alias to be hashed
   * @return {String} hashed alias
   */


  static hashAndSerializeAlias(alias) {
    alias.realm = undefined; // backend clears realm before hashing

    return bs58.encode(sha256(Buffer$1.from(stringify(alias), 'utf8')));
  }
  /**
   * Hash a string value.
   *
   * @param {string} value - value to be hahsed
   * @return {string} hashed value
   */


  static hashString(value) {
    return bs58.encode(sha256(Buffer$1.from(value, 'utf8')));
  }
  /**
   * Gets the signing key from a list of keys corresponding to the signature.
   *
   * @param {Array} keys -  list of keys
   * @param {Object} signature - signature
   * @return {Object} the signing key
   */


  static getSigningKey(keys, signature) {
    for (const key of keys) {
      if (key.id === signature.keyId) {
        return key;
      }
    }

    throw new Error('Invalid signature');
  }
  /**
   * Converts a key to string.
   *
   * @param {Uint8Array} key - key to encode
   * @return {string} encoded key
   */


  static strKey(key) {
    if (typeof key === 'string') return key;
    return base64Url(key);
  }
  /**
   * Wraps buffer as an Uint8Array object.
   *
   * @param {string|Buffer} buffer - data
   * @return {Uint8Array} data
   */


  static wrapBuffer(buffer) {
    return new Uint8Array(Buffer$1.from(buffer));
  }
  /**
   * Converts a key from a string to buffer.
   *
   * @param {string} key - base64url encoded key
   * @return {Uint8Array} buffered key
   */


  static bufferKey(key) {
    return Util.wrapBuffer(base64UrlToBuffer(key));
  }

  static parseParamsFromUrl(url) {
    const query = url.split('?')[1];
    const result = {};
    query.split('&').forEach(function (part) {
      const item = part.split('=');

      if (result[item[0]]) {
        // for parsing set transfer destinations url callback parameters
        if (_Array$isArray(result[item[0]])) {
          result[item[0]] = [...result[item[0]], decodeURIComponent(item[1])];
        } else result[item[0]] = [result[item[0]], decodeURIComponent(item[1])]; // first pass

      } else result[item[0]] = decodeURIComponent(item[1]);
    });
    return result;
  }

  static setUpHttpErrorLogging(instance) {
    instance.interceptors.response.use(res => res, (err = {}) => {
      /* eslint-disable */
      err.response ? console.error(`API response error: ${err.response.status} ${err.response.statusText}, ${err.response.data} [${err.response.config && err.response.config.url}]`) : console.error(`API no response: [${err.config && err.config.url}]`);
      /* eslint-enable */

      return _Promise.reject(err);
    });
  }

  static setUpCustomResponseInterceptor(instance, cri) {
    cri && instance.interceptors.response.use(cri.onFulfilled, cri.onRejected);
  }

}

/**
 * Class providing static crypto primitives.
 */

class Crypto {
  /**
   * Generates a key pair to use with the Token system.
   *
   * @param {string} keyLevel - 'LOW', 'STANDARD', or 'PRIVILEGED'
   * @param {number} expirationMs - (optional) expiration duration of the key in milliseconds
   * @return {Object} generated key pair
   */
  static generateKeys(keyLevel, expirationMs) {
    const keyPair = nacl.sign.keyPair();
    keyPair.id = base64Url(sha256(keyPair.publicKey)).substring(0, 16);
    keyPair.algorithm = 'ED25519';
    keyPair.level = keyLevel;
    keyPair.privateKey = keyPair.secretKey;
    if (expirationMs) keyPair.expiresAtMs = (new Date().getTime() + expirationMs).toString();
    delete keyPair.secretKey;
    return keyPair;
  }
  /**
   * Signs a json object and returns the signature
   *
   * @param {Object} json - object to sign
   * @param {Object} keys - keys to sign with
   * @return {string} signature
   */


  static signJson(json, keys) {
    return Crypto.sign(stringify(json), keys);
  }
  /**
   * Signs a string and returns the signature.
   *
   * @param {string} message - message to sign
   * @param {Object} keys - keys to sign with
   * @return {string} signature
   */


  static sign(message, keys) {
    const msg = Util.wrapBuffer(message);
    return base64Url(nacl.sign.detached(msg, keys.privateKey));
  }
  /**
   * Helper function for crypto engine createSigner:
   * returns a signer that uses a key pair.
   *
   * @param {Object} keyPair - such as returned by Token.Crypto.generateKeys
   * @return {Object} signer object
   */


  static createSignerFromKeyPair(keyPair) {
    return {
      sign: async message => {
        return await Crypto.sign(message, keyPair);
      },
      signJson: async json => {
        return await Crypto.signJson(json, keyPair);
      },
      getKeyId: () => keyPair.id
    };
  }
  /**
   * Verifies a signature on a JSON object. Throws if verification fails.
   *
   * @param {Object} json - JSON object to verify
   * @param {string} signature - signature to verify
   * @param {Uint8Array} publicKey - public key to use for verification
   */


  static verifyJson(json, signature, publicKey) {
    Crypto.verify(stringify(json), signature, publicKey);
  }
  /**
   * Verifies a signature on a string. Throws if verification fails.
   *
   * @param {string} message - string to verify
   * @param {string} signature - signature to verify
   * @param {Uint8Array} publicKey - public key to use for verification
   */


  static verify(message, signature, publicKey) {
    const msg = Util.wrapBuffer(message);
    const sig = Util.bufferKey(signature);
    const result = nacl.sign.detached.verify(msg, sig, publicKey);

    if (!result) {
      throw new Error(`Invalid signature ${signature} on message ${message} with pk ${publicKey}`);
    }
  }
  /**
   * Helper function for crypto engine createVerifier:
   * returns a signer that uses a key pair.
   *
   * @param {Object} keyPair - such as returned by Token.Crypto.generateKeys, only public key
   * @return {Object} verifier object
   */


  static createVerifierFromKeyPair(keyPair) {
    return {
      verify: async (message, signature) => {
        return await Crypto.verify(message, signature, keyPair.publicKey);
      },
      verifyJson: async (json, signature) => {
        return await Crypto.verifyJson(json, signature, keyPair.publicKey);
      }
    };
  }

}

/**
 * RPC error handler that facilitates handling cross-cutting API errors. Converts generic
 * StatusRuntimeException instances into specific Exception types to be handled by the callers.
 *
 * The globalRpcErrorCallback is invoked with a {name, message} error object any time
 * a custom RPC error occurs.
 */
class ErrorHandler {
  /**
   * Creates the error handler instance.
   *
   * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
   * call error. For example: SDK version mismatch
   */
  constructor(globalRpcErrorCallback) {
    this._globalRpcErrorCallback = globalRpcErrorCallback;
  }
  /**
   * Handles RPC error and calls the globalRpcErrorCallback.
   *
   * @param {object} error - error to handle
   * @return {object} original RPC error
   */


  handleError(error) {
    if (error.response && error.response.headers) {
      const tokenError = error.response.headers['token-error'];
      const tokenErrorDetails = error.response.headers['token-error-details'];

      if (tokenErrorDetails) {
        // Log optional error details to ease up troubleshooting.
        // Available only in non-prod deployments.
        console.log('Error details: ', tokenErrorDetails); // eslint-disable-line
      }

      if (this._globalRpcErrorCallback) {
        const name = tokenError ? tokenError : 'UNKNOWN';
        const mappedError = {
          name,
          message: error.response.data
        };

        this._globalRpcErrorCallback(mappedError);

        return mappedError;
      }
    }

    return error;
  }

}

/**
 * Class to add sdk developer key.
 */
class DeveloperHeader {
  /**
   * Initializes the developer header with the developer key.
   *
   * @param {string} developerKey - the developer key, by default empty
   */
  constructor(developerKey = '') {
    this._developerKey = developerKey;
  }
  /**
   * Adds the developer key to the request config if not empty.
   *
   * @param {Object} config - config of the request
   */


  addDeveloperHeader(config) {
    if (this._developerKey === '') {
      throw new ReferenceError('Please provide a developer key.' + ' Contact Token for more details.');
    } else {
      config.headers['token-dev-key'] = this._developerKey;
    }
  }

}

/**
 * Class to add sdk version and type.
 */
class VersionHeader {
  /**
   * Adds the sdk type and version to the request config.
   *
   * @param {Object} config - config of the request
   */
  addVersionHeader(config) {
    config.headers['token-sdk'] = "js-tpp";
    config.headers['token-sdk-version'] = "1.0.34";
  }

}

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Client for making unauthenticated requests to the Token gateway.
 */

class HttpClient {
  constructor({
    env = 'prd',
    developerKey,
    globalRpcErrorCallback,
    loggingEnabled,
    customSdkUrl,
    customResponseInterceptor
  }) {
    if (!(config.urls[env] || customSdkUrl)) {
      throw new Error('Invalid environment string. Please use one of: ' + _JSON$stringify(config.urls));
    }

    this._instance = axios.create({
      baseURL: customSdkUrl || config.urls[env]
    });

    if (loggingEnabled) {
      Util.setUpHttpErrorLogging(this._instance);
    }

    Util.setUpCustomResponseInterceptor(this._instance, customResponseInterceptor);
    const versionHeader = new VersionHeader();
    const developerHeader = new DeveloperHeader(developerKey);

    this._instance.interceptors.request.use(request => {
      versionHeader.addVersionHeader(request);
      developerHeader.addDeveloperHeader(request);
      return request;
    });

    const errorHandler = new ErrorHandler(globalRpcErrorCallback);

    this._instance.interceptors.response.use(null, error => {
      throw errorHandler.handleError(error);
    });
  }

  async normalizeAlias(alias) {
    const request = {
      method: 'get',
      url: `/aliases/normalize/${alias.type}/${alias.value}/${alias.realm || 'token'}`
    };
    return this._instance(request);
  }
  /**
   * Gets a member given an alias.
   *
   * @param {Object} alias - alias to lookup
   * @return {Object} response to the API call
   */


  async resolveAlias(alias) {
    const request = {
      method: 'get',
      url: `/resolve-alias?alias.value=${alias.value}&alias.type=${alias.type}&alias.realm=${alias.realm || ''}&alias.realmId=${alias.realmId || ''}` // eslint-disable-line max-len

    };
    return this._instance(request);
  }
  /**
   * Gets the member's information.
   *
   * @param {string} memberId - member ID to lookup the member for
   * @return {Object} response to the API call
   */


  async getMember(memberId) {
    const request = {
      method: 'get',
      url: `/members/${memberId}`
    };
    return this._instance(request);
  }
  /**
   * Gets banks or countries.
   *
   * @param {Object} options - optional parameters
   * @param {boolean} getCountries - get countries instead of banks if true
   * @return {Object} response to the API call
   */


  async getBanksOrCountries(options = {}, getCountries) {
    const formattedOptions = _extends({}, {
      // Can be at most 1000
      ids: options.ids || [],
      search: options.search || '',
      country: options.country || '',
      // Default to 1 if not specified
      page: options.page,
      // Can be at most 200, default to 200 if not specified
      perPage: options.perPage,
      // Optional provider
      provider: options.provider || '',
      // Optional destination country
      destinationCountry: options.destinationCountry || '',
      // (Optional) Filter for banks that support or don't support certain features. See Bank for the feature keys we support.
      // Set "true" for banks that support the feature or "false" for banks that don't support the feature.
      // e.g. ["supports_linking_uri": "true"] means only banks who supports the linking uri feature.
      bankFeatures: options.bankFeatures || ''
    });

    const {
      ids,
      search,
      country,
      page,
      perPage,
      provider,
      destinationCountry,
      bankFeatures
    } = formattedOptions;
    let url = `/banks${getCountries ? '/countries' : ''}?`;

    for (const id of ids) {
      url += `ids=${encodeURIComponent(id)}&`;
    }

    if (search) url += `search=${encodeURIComponent(search)}&`;
    if (country) url += `country=${encodeURIComponent(country)}&`;
    if (page) url += `page=${encodeURIComponent(page)}&`;
    if (perPage) url += `perPage=${encodeURIComponent(perPage)}&`;
    if (provider) url += `provider=${encodeURIComponent(provider)}&`;
    if (destinationCountry) url += `destinationCountry=${encodeURIComponent(destinationCountry)}&`;

    if (bankFeatures) {
      for (const key in bankFeatures) {
        url += `${key}=${encodeURIComponent(bankFeatures[key])}&`;
      }
    }

    const request = {
      method: 'get',
      url: url
    };
    return this._instance(request);
  }
  /**
   * Returns the Token member.
   *
   * @return {Promise} response to the API call
   */


  async getTokenMember() {
    const resolveAliasRes = await this.resolveAlias(Util.tokenAlias());
    const tokenMemberId = resolveAliasRes.data.member.id;
    const getMemberRes = await this.getMember(tokenMemberId);
    return getMemberRes.data.member;
  }
  /**
   * Creates a memberId.
   *
   * @param  {string} memberType - type of member to create. 'PERSONAL' if undefined
   * @param  {string} tokenRequestId - (optional) token request ID if the member is being claimed
   * @param  {string} realmId - (optional) member id of the Member to which this new member will belong
   * @return {Object} response to the API call
   */


  async createMemberId(memberType, tokenRequestId, realmId) {
    if (memberType === undefined) {
      memberType = 'PERSONAL';
    }

    if (tokenRequestId && memberType !== 'TRANSIENT') {
      throw new Error('Can only claim transient members');
    }

    const req = {
      memberType,
      tokenRequestId,
      realmId
    };
    const request = {
      method: 'post',
      url: '/members',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Approve a first key for a member (self signed).
   *
   * @param {string} memberId - ID of the member
   * @param {Object} key - key to approve
   * @param {Object} cryptoEngine - engine to use for signing
   * @return {Object} response to the API call
   */


  async approveFirstKey(memberId, key, cryptoEngine) {
    const signer = await cryptoEngine.createSigner(config.KeyLevel.PRIVILEGED);
    const update = {
      memberId: memberId,
      operations: [{
        addKey: {
          key: _objectSpread({
            id: key.id,
            publicKey: Util.strKey(key.publicKey),
            level: key.level,
            algorithm: key.algorithm
          }, key.expiresAtMs && {
            expiresAtMs: key.expiresAtMs
          })
        }
      }]
    };
    const req = {
      update,
      updateSignature: {
        memberId: memberId,
        keyId: signer.getKeyId(),
        signature: await signer.signJson(update)
      }
    };
    const request = {
      method: 'post',
      url: `/members/${memberId}/updates`,
      data: req
    };
    return this._instance(request);
  }
  /**
   * Approve the first keys for a member (self signed).
   *
   * @param {string} memberId - ID of the member
   * @param {Array} keys - keys to approve
   * @param {Object} cryptoEngine - engine to use for signing
   * @return {Object} response to the API call
   */


  async approveFirstKeys(memberId, keys, cryptoEngine) {
    const signer = await cryptoEngine.createSigner(config.KeyLevel.PRIVILEGED);
    const update = {
      memberId: memberId,
      operations: keys.map(key => ({
        addKey: {
          key: _objectSpread({
            id: key.id,
            publicKey: Util.strKey(key.publicKey),
            level: key.level,
            algorithm: key.algorithm
          }, key.expiresAtMs && {
            expiresAtMs: key.expiresAtMs
          })
        }
      }))
    };
    const req = {
      update,
      updateSignature: {
        memberId: memberId,
        keyId: signer.getKeyId(),
        signature: await signer.signJson(update)
      }
    };
    const request = {
      method: 'post',
      url: `/members/${memberId}/updates`,
      data: req
    };
    return this._instance(request);
  }

}

/**
 * Base crypto engine that are extended by others.
 * It handles signatures, verifications, and key storage.
 */
class KeyStoreCryptoEngine {
  constructor(memberId, keystore, crypto = Crypto) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!keystore) {
      throw new Error('Invalid keystore');
    }

    this._memberId = memberId;
    this._keystore = keystore;
    this._crypto = crypto;

    if (memberId && keystore.constructor.setActiveMemberId) {
      keystore.constructor.setActiveMemberId(memberId);
    }
  }
  /**
   * Generates a key pair and store it.
   *
   * @param level - 'LOW', 'STANDARD', or 'PRIVILEGED'
   * @param expirationMs - (optional) expiration duration of the key in milliseconds
   * @return key in proto-compliant format
   */


  async generateKey(level, expirationMs) {
    const keyPair = await this._crypto.generateKeys(level, expirationMs);
    const stored = await this._keystore.put(this._memberId, keyPair);
    stored.publicKey = Util.strKey(stored.publicKey);
    delete stored.privateKey;
    return stored;
  }
  /**
   * Creates a signer. Assumes we previously generated the relevant key.
   *
   * @param level - privilege level 'LOW', 'STANDARD', 'PRIVILEGED'
   * @return signer object that implements sign, signJson, and getKeyId
   */


  async createSigner(level) {
    const keyPair = await this._keystore.getByLevel(this._memberId, level);
    return this._crypto.createSignerFromKeyPair(keyPair);
  }
  /**
   * Creates a verifier. Assumes we have the key with the passed ID.
   *
   * @param keyId - ID of key to use
   * @return verifier object that implements verify and verifyJson
   */


  async createVerifier(keyId) {
    const keyPair = await this._keystore.getById(this._memberId, keyId);
    return this._crypto.createVerifierFromKeyPair(keyPair);
  }

}

const globalStorage = {};

class MemoryKeyStore {
  /**
   * Store a member's key pair.
   *
   * @param {string} memberId - ID of member
   * @param {Object} keyPair - key pair to store
   * @return {Object} the stored key pair
   */
  async put(memberId, keyPair) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!keyPair) {
      throw new Error('Don\'t know what key to put');
    }

    if (!keyPair.level) {
      throw new Error('Invalid key structure: has no privilege level');
    }

    if (keyPair.expiresAtMs < _Date$now()) {
      throw new Error(`Key ${keyPair.id} has expired`);
    }

    if (!globalStorage[memberId]) {
      globalStorage[memberId] = {};
    }

    globalStorage[memberId][keyPair.level] = clone(keyPair);
    globalStorage.ACTIVE = memberId;
    return clone(globalStorage[memberId][keyPair.level]);
  }
  /**
   * Look up a key by memberId and level.
   *
   * @param {string} memberId - ID of member
   * @param {string} level - 'LOW', 'STANDARD', or 'PRIVILEGED'
   * @return {Object} key pair
   */


  async getByLevel(memberId, level) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!level) {
      throw new Error('Don\'t know what key level to get');
    }

    if (!globalStorage[memberId]) {
      throw new Error(`member ${memberId} not found`);
    }

    if (!globalStorage[memberId][level]) {
      throw new Error(`No key with level ${level} found`);
    }

    if (globalStorage[memberId][level].expiresAtMs < _Date$now()) {
      throw new Error(`Key with level ${level} has expired`);
    }

    return clone(globalStorage[memberId][level]);
  }
  /**
   * Look up a key by memberId and keyId.
   *
   * @param {string} memberId - ID of member
   * @param {string} keyId - key ID
   * @return {Object} key pair
   */


  async getById(memberId, keyId) {
    if (!globalStorage[memberId]) {
      throw new Error(`member ${memberId} not found`);
    }

    if (!keyId) {
      throw new Error('Don\'t know id of key to get');
    }

    for (const level in globalStorage[memberId]) {
      if (Object.prototype.hasOwnProperty.call(globalStorage[memberId], level)) {
        if (globalStorage[memberId][level].id === keyId) {
          if (globalStorage[memberId][level].expiresAtMs < _Date$now()) {
            throw new Error('Key with id ${globalStorage[memberId][level].id} has expired');
          }

          return clone(globalStorage[memberId][level]);
        }
      }
    }

    throw new Error(`No key with id ${keyId} found`);
  }
  /**
   * Return list of member's keys.
   *
   * @param {string} memberId - ID of member
   * @return {Object} list of keys
   */


  async listKeys(memberId) {
    if (!globalStorage[memberId]) {
      throw new Error(`member ${memberId} not found`);
    }

    return _Object$keys(globalStorage[memberId]).map(level => clone(globalStorage[memberId][level])).filter(keyPair => !(keyPair.expiresAtMs < _Date$now()));
  }
  /**
   * Keep track of the ID of the most recently active member.
   *
   * @param {string} memberId - ID of member
   */


  static setActiveMemberId(memberId) {
    globalStorage.ACTIVE = memberId;
  }
  /**
   * Get the ID of the most recently active member.
   *
   * @return {string} ID of member
   */


  static getActiveMemberId() {
    const memberId = globalStorage.ACTIVE;

    if (!memberId) {
      throw new Error('No active memberId');
    }

    return memberId;
  }

}
/**
 * Return a (shallow) copy of an object.
 *
 * If the 'user' of a key pair object edits it (e.g., deleting privateKey),
 * that shouldn't affect the 'stored' key pair. Thus, we can't pass around
 * references to stored objects. Instead, we do some object-copying.
 *
 * @param {Object} obj - object to copy
 * @return {Object} copy of obj
 */


function clone(obj) {
  return _extends({}, obj);
}

/**
 * MemoryCryptoEngine: Implements the CryptoEngine interface.
 *
 * Crypto engine to handle signatures, verifications, and key storage, in memory. Handles storage
 * for multiple members at once, and uses the following schema:
 *
 * {
 *   'ACTIVE': 'm:12345:678', // member ID of most-recently active member
 *   'm:12345:678': { // a member's keys:
 *     'PRIVILEGED': {
 *          ID: '456', // key ID
 *          algorithm: ED25519,
 *          level: PRIVILEGED,
 *          publicKey: Buffer(...), // public key data
 *          privateKey: Buffer(...), // secret key data
 *      },
 *     'LOW': {...},
 *     'STANDARD': {...},
 *   },
 *   'm:91011:12d': {...} // other member's keys...
 * }
 *
 */

const globalKeyStore = new MemoryKeyStore();

class MemoryCryptoEngine extends KeyStoreCryptoEngine {
  constructor(memberId) {
    super(memberId, globalKeyStore);
  }
  /**
   * Gets the currently active memberId.
   * This allows login without caching memberId somewhere
   *
   * @return {string} active memberId
   */


  static getActiveMemberId() {
    const memberId = MemoryKeyStore.getActiveMemberId();

    if (!memberId) {
      throw new Error('No active memberId on this browser');
    }

    return memberId;
  }

}

let keys = [];
const globalKeyStore$1 = new MemoryKeyStore();
/**
 * Crypto engine that handles hardcoded keys
 */

class ManualCryptoEngine extends KeyStoreCryptoEngine {
  /**
   * Set the hardcoded keys used by ManualCryptoEngine
   *
   * @param {Array} memberKeys - keys to set
   *
   * Must be an array with objects of the format:
   * {
   *     publicKey: '123456',
   *     privateKey: '123456',
   *     level: 'LOW' || 'STANDARD' || 'PRIVILEGED',
   * }
   */
  static async setKeys(memberKeys) {
    if (!memberKeys || !_Array$isArray(memberKeys) || memberKeys.length < 1) {
      throw new Error('invalid keys format');
    }

    keys = memberKeys;

    for (const keyPair of keys) {
      if (!keyPair.publicKey || !keyPair.privateKey || !keyPair.level) {
        throw new Error('Invalid keyPair format');
      }

      if (typeof keyPair.privateKey === 'string') {
        keyPair.privateKey = Util.bufferKey(keyPair.privateKey);
      }

      if (!keyPair.id) {
        keyPair.id = base64Url(sha256(Util.bufferKey(keyPair.publicKey))).substring(0, 16);
      }

      keyPair.algorithm = 'ED25519';
    }
  }

  constructor(memberId) {
    if (keys.length < 1) {
      throw new Error('Keys must be set before constructing.');
    }

    super(memberId, globalKeyStore$1);
  }
  /**
   * Generate a keyPair and store it.
   *
   * @param {string} level - privilege level 'LOW', 'STANDARD', 'PRIVILEGED'
   * @return {Object} key
   */


  async generateKey(level) {
    for (const keyPair of keys) {
      if (keyPair.level === level) {
        const cloned = clone$1(keyPair);

        if (cloned.privateKey) {
          delete cloned.privateKey;
        }

        return cloned;
      }
    }
  }
  /**
   * Create a signer. Assumes we previously generated the relevant key.
   *
   * @param {string} level - privilege level 'LOW', 'STANDARD', 'PRIVILEGED'
   * @return {Object} object that implements sign, signJson
   */


  async createSigner(level) {
    const keyPairs = keys.filter(k => k.level === level);

    if (!keyPairs || !keyPairs.length) {
      throw new Error(`No key with level ${level} found`);
    }

    return this._crypto.createSignerFromKeyPair(clone$1(keyPairs[0]));
  }
  /**
   * Create a verifier. Assumes we have the key with the passed ID.
   *
   * @param {string} keyId - ID of key to use
   * @return {Object} object that implements verify, verifyJson
   */


  async createVerifier(keyId) {
    const keyPairs = keys.filter(k => k.id === keyId);

    if (!keyPairs || !keyPairs.length) {
      throw new Error(`No key with id ${keyId} found`);
    }

    return this._crypto.createVerifierFromKeyPair(clone$1(keyPairs[0]));
  }

}
/**
 * Return a (shallow) copy of an object.
 *
 * If the 'user' of a key pair object edits it (e.g., deleting privateKey),
 * that shouldn't affect the 'stored' key pair. Thus, we can't pass around
 * references to stored objects. Instead, we do some object-copying.
 *
 * @param {Object} obj - object to copy
 * @return {Object} copy of obj
 */


function clone$1(obj) {
  return _extends({}, obj);
}

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Token SDK entry point.
 */
class TokenClient {
  constructor(options = {}) {
    this.options = options;
    this.options.developerKey = this.options.developerKey || config.devKey.default;
    this.KeyLevel = config.KeyLevel;
    this.Crypto = Crypto;
    this.MemoryCryptoEngine = MemoryCryptoEngine;
    this.ManualCryptoEngine = ManualCryptoEngine;
  }
  /**
   * Resolve an alias to a member.
   *
   * @param alias - alias to lookup
   * @return TokenMember
   */


  resolveAlias(alias) {
    return Util.callAsync(this.resolveAlias, async () => {
      const res = await this._unauthenticatedClient.resolveAlias(alias);
      return res.data.member;
    });
  }
  /**
   * Creates a Token member with an alias.
   *
   * @param alias - the member's alias
   * @param CryptoEngine - engine to use for key creation and storage
   * @param Member - Member class for creation
   * @param memberType - type of member to create. "PERSONAL" if undefined
   * @param tokenRequestId - (optional) token request ID if the member is being claimed
   * @param realmId - (optional) member id of the Member to which this new member will belong
   * @return Promise of created Member
   */


  createMemberCore(alias, CryptoEngine, Member, memberType, tokenRequestId, realmId) {
    return Util.callAsync(this.createMemberCore, async () => {
      const response = await this._unauthenticatedClient.createMemberId(memberType, tokenRequestId, realmId);
      const engine = new CryptoEngine(response.data.memberId);
      const pk1 = await engine.generateKey('PRIVILEGED');
      const pk2 = await engine.generateKey('STANDARD');
      const pk3 = await engine.generateKey('LOW');
      await this._unauthenticatedClient.approveFirstKeys(response.data.memberId, [pk1, pk2, pk3], engine);
      const member = new Member(_objectSpread$1({
        memberId: response.data.memberId,
        cryptoEngine: engine
      }, this.options));
      alias && (await member.addAlias(alias));
      return member;
    });
  }
  /**
   * Returns 'logged-in' member that uses keys already in the CryptoEngine.
   * If memberId is not provided, the last member to 'log in' will be used.
   *
   * @param CryptoEngine - engine to use for key creation and storage
   * @param Member - Member class for creation
   * @param memberId - optional ID of the member we want to log in
   * @return instantiated member
   */


  getMemberCore(CryptoEngine, Member, memberId) {
    return Util.callSync(this.getMemberCore, () => {
      if (!memberId && typeof CryptoEngine.getActiveMemberId === 'function') {
        memberId = CryptoEngine.getActiveMemberId();
      }

      const engine = new CryptoEngine(memberId);
      return new Member(_objectSpread$1({
        memberId,
        cryptoEngine: engine
      }, this.options));
    });
  }
  /**
   * Gets a list of countries with Token-enabled banks.
   *
   * @param options - optional parameters for getBanks
   * @return list of banks
   */


  getBanks(options) {
    return Util.callAsync(this.getBanks, async () => {
      const res = await this._unauthenticatedClient.getBanksOrCountries(options);
      return {
        banks: res.data.banks || [],
        paging: res.data.paging
      };
    });
  }
  /**
   * Gets a list of available countries for linking.
   *
   * @param options - optional parameters for getBanksCountries
   * @return list of countries with linkable banks
   */


  getCountries(options) {
    return Util.callAsync(this.getBanks, async () => {
      const res = await this._unauthenticatedClient.getBanksOrCountries(options, true);
      return res.data.countries;
    });
  }

}

/**
 * Handles the addition of the http headers (with signature) to the request
 */

class AuthHeader {
  /**
   * Creates an AuthHeader object with set url and signer
   *
   * @param {string} baseUrl - url to send requests to (gateway)
   * @param {Object} client - client, to get the signer
   */
  constructor(baseUrl, client) {
    this._baseUrl = baseUrl;
    this._client = client;
  }
  /**
   * Adds an authorization header to the request. This takes into account the url,
   * payload of the request (with timestamp), to generate a message and signature.
   * All of it goes into the Authorization http header.
   *
   * @param {string} memberId - memberId making the request
   * @param {Object} request - request
   * @param {AuthContext} context - auth context for access token redemption
   */


  async addAuthorizationHeader(memberId, request, context) {
    const now = new Date().getTime(); // Parses out the base uri

    let uriPath = request.url.replace(this._baseUrl, ''); // Makes sure the uri is formatted correctly

    uriPath = uriPath.substring(0, 1) === '/' ? uriPath : `/${uriPath}`;
    uriPath = uriPath.substring(uriPath.length - 1) === '/' ? uriPath.substring(0, uriPath.length - 1) : uriPath; // Path should not include query parameters

    if (uriPath.indexOf('?') >= 0) {
      uriPath = uriPath.substring(0, uriPath.indexOf('?'));
    } // Creates the payload from the request info


    const payload = {
      method: request.method.toUpperCase(),
      uriHost: this._baseUrl.replace('http://', '').replace('https://', ''),
      uriPath,
      createdAtMs: now.toString()
    };

    if (request.data !== undefined && request.data !== '') {
      payload.requestBody = stringify(request.data);
    } // Signs the query string as well, if it exists


    if (request.url.indexOf('?') !== -1) {
      payload.queryString = request.url.substring(request.url.indexOf('?') + 1);
    } // Creates the signer object


    const signer = await this._client.getSigner(AuthHeader._keyLevel(context)); // Signs the Json string

    const signature = await signer.signJson(payload); // Creates the authorization header, ands adds it to the request

    const header = config.signatureScheme + ' ' + 'member-id=' + memberId + ',' + 'key-id=' + signer.getKeyId() + ',' + 'signature=' + signature + ',' + 'created-at-ms=' + now + AuthHeader._onBehalfOfHeader(context) + AuthHeader._customerInitiated(context);

    request.headers = {
      Authorization: header
    };
  }

  static _onBehalfOfHeader(context) {
    if (context !== undefined && context.onBehalfOf !== undefined && context.onBehalfOf !== '') {
      return ',on-behalf-of=' + context.onBehalfOf;
    }

    return '';
  }

  static _keyLevel(context) {
    // if we specified that this request should use a keyLevel > LOW, we notice that here
    // (and re-set the keyLevel for the next request)
    if (context !== undefined) {
      const level = context.keyLevel;
      context.keyLevel = config.KeyLevel.LOW;
      return level;
    }

    return config.KeyLevel.LOW;
  }

  static _customerInitiated(context) {
    // if the customer initiated request flag is set to true,
    // we add it to the header, and reset the flag.
    if (context && context.customerInitiated) {
      context.customerInitiated = false;
      return ',customer-initiated=true';
    }

    return '';
  }

}

/**
 * Handles the auth context when using access tokens.
 */

class AuthContext {
  /**
   * Creates an AuthContext object
   */
  constructor() {
    this._onBehalfOf = undefined;
    this._keyLevel = config.KeyLevel.LOW;
    this._customerInitiated = false;
  }
  /**
   * Sets the auth context to act on behalf of another member
   *
   * @param {string} onBehalfOf - accessTokenId to use
   */


  set onBehalfOf(onBehalfOf) {
    this._onBehalfOf = onBehalfOf;
  }
  /**
  * Sets the key level to be used to sign the auth header
  *
  * @param {string} keyLevel - key Level to use
  */


  set keyLevel(keyLevel) {
    this._keyLevel = keyLevel === undefined ? config.KeyLevel.LOW : keyLevel;
  }
  /**
   * Sets the auth context to indicate that the next api call
   * would have been initiated by the customer.
   *
   * @param {boolean} flag - true if request initiated by customer
   */


  set customerInitiated(flag) {
    this._customerInitiated = flag;
  }
  /**
   * Gets the currently active memberId
   *
   * @return {string} accessTokenId being used
   */


  get onBehalfOf() {
    return this._onBehalfOf;
  }
  /**
   * Gets the key level
   *
   * @return {string} key level being used
   */


  get keyLevel() {
    return this._keyLevel;
  }
  /**
   * Gets the customer initiated request flag.
   *
   * @return {boolean} true if request initiated by customer
   */


  get customerInitiated() {
    return this._customerInitiated;
  }

}

class SecurityMetadataHeader {
  /**
   * Initializes with security metadata to add to the request.
   *
   * @param {string} securityMetadata - security metadata
   */
  constructor(securityMetadata) {
    this._securityMetadata = securityMetadata;
  }
  /**
   * Adds security metadata to the request.
   *
   * @param {Object} request - request
   */


  addSecurityMetadataHeader(request) {
    if (this._securityMetadata) {
      request.headers['token-security-metadata'] = base64Url(stringify(this._securityMetadata));
    }
  }

}

function ownKeys$2(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Client for making authenticated requests to the Token gateway.
 */

class AuthHttpClient {
  constructor({
    env,
    memberId,
    cryptoEngine,
    developerKey,
    globalRpcErrorCallback,
    loggingEnabled,
    customSdkUrl,
    customResponseInterceptor
  }) {
    if (!(config.urls[env] || customSdkUrl)) {
      throw new Error('Invalid environment string. Please use one of: ' + _JSON$stringify(config.urls));
    }

    this._instance = axios.create({
      baseURL: customSdkUrl || config.urls[env]
    });

    if (loggingEnabled) {
      Util.setUpHttpErrorLogging(this._instance);
    }

    Util.setUpCustomResponseInterceptor(this._instance, customResponseInterceptor);
    this._memberId = memberId;
    this._cryptoEngine = cryptoEngine;
    this._context = new AuthContext();
    this._authHeader = new AuthHeader(customSdkUrl || config.urls[env], this);
    this._developerKey = developerKey;

    this._resetRequestInterceptor();

    const errorHandler = new ErrorHandler(globalRpcErrorCallback);

    this._instance.interceptors.response.use(null, error => {
      throw errorHandler.handleError(error);
    });
  }
  /**
   * Creates the necessary signer objects, based on the level requested.
   * If the level is not available, attempts to fetch a lower level.
   *
   * @param {string} level - requested level of key
   * @return {Promise} object used to sign
   */


  async getSigner(level) {
    if (level === config.KeyLevel.LOW) {
      return await this._cryptoEngine.createSigner(config.KeyLevel.LOW);
    }

    if (level === config.KeyLevel.STANDARD) {
      try {
        return await this._cryptoEngine.createSigner(config.KeyLevel.STANDARD);
      } catch (err) {
        return await this._cryptoEngine.createSigner(config.KeyLevel.LOW);
      }
    }

    if (level === config.KeyLevel.PRIVILEGED) {
      try {
        return await this._cryptoEngine.createSigner(config.KeyLevel.PRIVILEGED);
      } catch (err) {
        try {
          return await this._cryptoEngine.createSigner(config.KeyLevel.STANDARD);
        } catch (err2) {
          return await this._cryptoEngine.createSigner(config.KeyLevel.LOW);
        }
      }
    }
  }
  /**
   * Use the given key level to sign the request.
   *
   * @param {string} keyLevel - key level
   */


  useKeyLevel(keyLevel) {
    this._context.keyLevel = keyLevel;

    this._resetRequestInterceptor();
  }
  /**
   * Sets the security metadata to be sent with each request.
   *
   * @param {object} securityMetadata - security metadata
   */


  setSecurityMetadata(securityMetadata) {
    this._securityMetadata = securityMetadata;

    this._resetRequestInterceptor();
  }
  /**
   * Clears the security metadata.
   */


  clearSecurityMetadata() {
    this._securityMetadata = undefined;

    this._resetRequestInterceptor();
  }
  /**
   * Returns the security metadata.
   *
   * @return {object} security metadata
   */


  getSecurityMetadata() {
    return this._securityMetadata;
  }
  /**
   * Gets all accounts linked to the member.
   *
   * @return {Object} response to the API call
   */


  async getAccounts() {
    const request = {
      method: 'get',
      url: '/accounts'
    };
    return this._instance(request);
  }
  /**
   * Gets an account.
   *
   * @param {string} accountId - account to get
   * @return {Object} response to the API call
   */


  async getAccount(accountId) {
    const request = {
      method: 'get',
      url: `/accounts/${accountId}`
    };
    return this._instance(request);
  }
  /**
   * Gets the balance of an account.
   *
   * @param {string} accountId - accountId
   * @param {string} keyLevel - key level
   * @return {Object} response to the API call
   */


  async getBalance(accountId, keyLevel) {
    this.useKeyLevel(keyLevel);
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/balance`
    };
    return this._instance(request);
  }
  /**
   * Gets the balances of an array of accounts.
   *
   * @param {Array} accountIds - array of accountIds
   * @param {string} keyLevel - key level
   * @return {Object} response to the API call
   */


  async getBalances(accountIds, keyLevel) {
    this.useKeyLevel(keyLevel);
    const url = '/account-balance?' + accountIds.map(accountId => 'account_id=' + accountId).join('&');
    const request = {
      method: 'get',
      url: url
    };
    return this._instance(request);
  }
  /**
   * Gets a transaction for an account, by its ID.
   *
   * @param {string} accountId - account that initiated the transaction
   * @param {string} transactionId - ID of the transaction
   * @param {string} keyLevel - key level
   * @return {Object} response to the API call
   */


  async getTransaction(accountId, transactionId, keyLevel) {
    this.useKeyLevel(keyLevel);
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/transaction/${transactionId}`
    };
    return this._instance(request);
  }
  /**
   * Gets all transactions for an account.
   *
   * @param {string} accountId - ID of the account
   * @param {string} offset - where to start
   * @param {Number} limit - how many to get
   * @param {string} keyLevel - key level
   * @return {Object} response to the API call
   */


  async getTransactions(accountId, offset, limit, keyLevel, startDate, endDate) {
    this.useKeyLevel(keyLevel);
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/transactions?offset=${offset}&limit=${limit}&startDate=${startDate || ''}&endDate=${endDate || ''}`
    };
    return this._instance(request);
  }
  /**
   * Confirms if an account has sufficient funds for a purchase.
   *
   * @param {string} accountId
   * @param {string} amount
   * @param {string} currency
   * @return {boolean} true if account has sufficient funds
   */


  async confirmFunds(accountId, amount, currency) {
    const req = {
      accountId,
      amount: {
        currency,
        value: amount.toString()
      }
    };
    const request = {
      method: 'put',
      url: `/accounts/${accountId}/funds-confirmation`,
      data: req
    };
    return this._instance(request);
  }
  /**
   * Gets info about a bank.
   *
   * @param {string} bankId - ID of the bank to lookup
   * @return {Object} response to the API call
   */


  async getBankInfo(bankId) {
    const request = {
      method: 'get',
      url: `/banks/${bankId}/info`
    };
    return this._instance(request);
  }
  /**
   * Adds a key to the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Object} key - key to add
   * @return {Object} response to the API call
   */


  async approveKey(prevHash, key) {
    const update = {
      memberId: this._memberId,
      operations: [{
        addKey: {
          key: _objectSpread$2({
            id: key.id,
            publicKey: Util.strKey(key.publicKey),
            level: key.level,
            algorithm: key.algorithm
          }, key.expiresAtMs && {
            expiresAtMs: key.expiresAtMs
          })
        }
      }]
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Adds keys to the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Array} keys - keys to add
   * @return {Object} response to the API call
   */


  async approveKeys(prevHash, keys) {
    const update = {
      memberId: this._memberId,
      operations: keys.map(key => ({
        addKey: {
          key: _objectSpread$2({
            id: key.id,
            publicKey: Util.strKey(key.publicKey),
            level: key.level,
            algorithm: key.algorithm
          }, key.expiresAtMs && {
            expiresAtMs: key.expiresAtMs
          })
        }
      }))
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Removes a key from the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {string} keyId - keyId to remove
   * @return {Object} response to the API call
   */


  async removeKey(prevHash, keyId) {
    const update = {
      memberId: this._memberId,
      operations: [{
        removeKey: {
          keyId
        }
      }]
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Removes keys from the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Array} keyIds - keys to remove
   * @return {Object} response to the API call
   */


  async removeKeys(prevHash, keyIds) {
    const update = {
      memberId: this._memberId,
      operations: keyIds.map(keyId => ({
        removeKey: {
          keyId
        }
      }))
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Adds an alias to the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Object} alias - alias to add
   * @return {Object} response to the API call
   */


  async addAlias(prevHash, alias) {
    return this.addAliases(prevHash, [alias]);
  }
  /**
   * Gets logged-in member's aliases, verified or not.
   *
   * @return {Object} response object; has aliases, unverifiedAliases
   */


  async getAliases() {
    const request = {
      method: 'get',
      url: '/aliases'
    };
    return this._instance(request);
  }
  /**
   * Get default recovery agent.
   * @return {Object} GetDefaultAgentResponse proto buffer
   */


  async getDefaultRecoveryAgent() {
    const request = {
      method: 'get',
      url: '/recovery/defaults/agent'
    };
    return this._instance(request);
  }
  /**
   * Set member's recovery rule.
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Object} rule - RecoveryRule proto buffer specifying behavior.
   * @return {Object} UpdateMemberResponse proto buffer
   */


  async addRecoveryRule(prevHash, rule) {
    const update = {
      memberId: this._memberId,
      operations: [{
        recoveryRules: rule
      }]
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Adds aliases to the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Array} aliases - aliases to add
   * @return {Object} response to the API call
   */


  async addAliases(prevHash, aliases) {
    const update = {
      memberId: this._memberId,
      operations: aliases.map(alias => ({
        addAlias: {
          aliasHash: Util.hashAndSerializeAlias(alias),
          realm: alias.realm,
          realmId: alias.realmId
        }
      }))
    };
    const metadata = aliases.map(alias => ({
      addAliasMetadata: {
        aliasHash: Util.hashAndSerializeAlias(alias),
        alias: alias
      }
    }));
    return this._memberUpdate(update, prevHash, metadata);
  }
  /**
   * Removes an alias from the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Object} alias - alias to remove
   * @return {Object} response to the API call
   */


  async removeAlias(prevHash, alias) {
    return this.removeAliases(prevHash, [alias]);
  }
  /**
   * Removes aliases from the member.
   *
   * @param {string} prevHash - hash of the previous directory entry.
   * @param {Array} aliases - aliases to remove
   * @return {Object} response to the API call
   */


  async removeAliases(prevHash, aliases) {
    const update = {
      memberId: this._memberId,
      operations: aliases.map(alias => ({
        removeAlias: {
          aliasHash: Util.hashAndSerializeAlias(alias),
          realm: alias.realm,
          realmId: alias.realmId
        }
      }))
    };
    return this._memberUpdate(update, prevHash);
  }
  /**
   * Deletes the member.
   *
   * @return {Object} response to the api call
   */


  async deleteMember() {
    this.useKeyLevel(config.KeyLevel.PRIVILEGED);
    const request = {
      method: 'delete',
      url: '/members'
    };
    return this._instance(request);
  }
  /**
   * Resolves transfer destinations for the given account ID.
   *
   * @param {string} accountId - ID of account to resolve destinations for
   * @return {Object} api response
   */


  async resolveTransferDestinations(accountId) {
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/transfer-destinations`
    };
    return this._instance(request);
  }
  /**
   * Creates a test bank account.
   *
   * @param {Number} balance - balance to put in the account
   * @param {string} currency - currency in the account
   * @return {Object} response to the API call
   */


  async createTestBankAccount(balance, currency) {
    const req = {
      balance: {
        currency,
        value: balance
      }
    };
    const request = {
      method: 'post',
      url: '/test/create-account',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Links accounts to the member.
   *
   * @param {string} authorization - oauthBankAuthorization continaing bank_id and
   * access_token
   * @return {Object} response to the API call
   */


  async linkAccountsOauth(authorization) {
    const req = {
      authorization
    };
    const request = {
      method: 'post',
      url: '/bank-accounts',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Gets test bank notification.
   *
   * @param {string} subscriberId - id of subscriber
   * @param {string} notificationId - id of notification
   * @return {Object} response to the API call
   */


  async getTestBankNotification(subscriberId, notificationId) {
    const request = {
      method: 'get',
      url: `/test/subscribers/${subscriberId}/notifications/${notificationId}`
    };
    return this._instance(request);
  }
  /**
   * Gets test bank notifications.
   *
   * @param {string} subscriberId - id of subscriber
   * @return {Object} response to the API call
   */


  async getTestBankNotifications(subscriberId) {
    const request = {
      method: 'get',
      url: `/test/subscribers/${subscriberId}/notifications`
    };
    return this._instance(request);
  }
  /**
   * Gets information about a particular standing order.
   *
   * @param {string} accountId
   * @param {string} standingOrderId
   * @param {string} keyLevel
   * @returns
   * @memberof AuthHttpClient
   */


  async getStandingOrder(accountId, standingOrderId, keyLevel) {
    this.useKeyLevel(keyLevel);
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/standing-orders/${standingOrderId}`
    };
    return this._instance(request);
  }
  /**
   * Gets information about several standing orders.
   *
   * @param {string} accountId
   * @param {string} offset
   * @param {int} limit
   * @param {string} keyLevel
   * @returns
   * @memberof AuthHttpClient
   */


  async getStandingOrders(accountId, offset, limit, keyLevel) {
    this.useKeyLevel(keyLevel);
    const request = {
      method: 'get',
      url: `/accounts/${accountId}/standing-orders?page.offset=${offset}&page.limit=${limit}`
    };
    return this._instance(request);
  }
  /**
   * Signs a token payload with given key level and action.
   *
   * @param {Object} tokenPayload
   * @param {string} suffix
   * @param {KeyLevel} keyLevel
   * @returns {Object} token proto signature object
   */


  async tokenOperationSignature(tokenPayload, suffix, keyLevel) {
    const payload = stringify(tokenPayload) + `.${suffix}`;
    const signer = await this.getSigner(keyLevel);
    return {
      memberId: this._memberId,
      keyId: signer.getKeyId(),
      signature: await signer.sign(payload)
    };
  }

  async _memberUpdate(update, prevHash, metadata) {
    if (prevHash !== '') {
      update.prevHash = prevHash;
    }

    if (typeof metadata === 'undefined') {
      metadata = [];
    }

    const signer = await this.getSigner(config.KeyLevel.PRIVILEGED);
    const req = {
      update,
      updateSignature: {
        memberId: this._memberId,
        keyId: signer.getKeyId(),
        signature: await signer.signJson(update)
      },
      metadata
    };
    const request = {
      method: 'post',
      url: `/members/${this._memberId}/updates`,
      data: req
    };
    return this._instance(request);
  }

  _resetRequestInterceptor() {
    this._instance.interceptors.request.eject(this._interceptor);

    const versionHeader = new VersionHeader();
    const developerHeader = new DeveloperHeader(this._developerKey);
    const securityMetadataHeader = new SecurityMetadataHeader(this._securityMetadata);
    this._interceptor = this._instance.interceptors.request.use(async request => {
      await this._authHeader.addAuthorizationHeader(this._memberId, request, this._context);
      versionHeader.addVersionHeader(request);
      developerHeader.addDeveloperHeader(request);
      securityMetadataHeader.addSecurityMetadataHeader(request);
      return request;
    });
  }

}

/**
 * Represents a bank account.
 */
class Account {
  /**
   * Use Member::getAccount(s).
   */
  constructor(account, member) {
    this.account = account;
    this.accountMember = member;
  }
  /**
   * Gets the account owner.
   *
   * @return member that owns the account
   */


  member() {
    return this.accountMember;
  }
  /**
   * Gets the account ID.
   *
   * @return the account ID
   */


  id() {
    return this.account.id;
  }
  /**
   * Gets the account name.
   *
   * @return name of the account
   */


  name() {
    return this.account.name;
  }
  /**
   * Gets the account's bank.
   *
   * @return the account's bank
   */


  bankId() {
    return this.account.bankId;
  }
  /**
   * Looks up if this account is locked.
   *
   * @return whether this account is locked
   */


  isLocked() {
    return this.account.isLocked;
  }
  /**
   * Looks up if this account supports retrieval of information such as balance.
   *
   * @return whether this account supports info
   */


  supportsInformation() {
    return this.account.accountFeatures.supportsInformation;
  }
  /**
   * Looks up if this account supports sending payment.
   *
   * @return whether this account supports sending payment
   */


  supportsSendPayment() {
    return this.account.accountFeatures.supportsSendPayment;
  }
  /**
   * Looks up if this account supports receiving payment.
   *
   * @return whether this account supports receiving payment
   */


  supportsReceivePayment() {
    return this.account.accountFeatures.supportsReceivePayment;
  }
  /**
   * Looks up if this account requires external authorization for creating transfers.
   *
   * @return whether this account requires external auth
   */


  requiresExternalAuth() {
    return this.account.accountFeatures.requiresExternalAuth;
  }
  /**
   * Fetches the raw account object.
   *
   * @return the account object
   */


  toProto() {
    return this.account;
  }
  /**
   * Looks up the account's balance.
   *
   * @param keyLevel
   * @return the account's balance
   */


  getBalance(keyLevel) {
    return Util.callAsync(this.getBalance, async () => {
      const res = await this.accountMember._client.getBalance(this.account.id, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.balance;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Balance step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up a transaction by ID.
   * @param transactionId
   * @param keyLevel
   * @return transaction
   */


  getTransaction(transactionId, keyLevel) {
    return Util.callAsync(this.getTransaction, async () => {
      const res = await this.accountMember._client.getTransaction(this.account.id, transactionId, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.transaction;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Transaction step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up the account's transactions.
   *
   * @param offset - where to start
   * @param limit - max number to retrieve
   * @param keyLevel
   * @return transactions
   */


  getTransactions(offset, limit, keyLevel) {
    return Util.callAsync(this.getTransactions, async () => {
      const res = await this.accountMember._client.getTransactions(this.account.id, offset, limit, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return {
            transactions: res.data.transactions || [],
            offset: res.data.offset
          };

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Transaction step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up an existing standing account order for a given account.
   *
   * @param standingOrderId
   * @param keyLevel
   * @return standing order record
   */


  getStandingOrder(standingOrderId, keyLevel) {
    return Util.callAsync(this.getStandingOrder, async () => {
      const res = await this.accountMember._client.getStandingOrder(this.account.id, standingOrderId, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.standingOrder;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Standing order step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up all of the member's standing orders on the account
   *
   * @param accountId
   * @param offset
   * @param limit
   * @param keyLevel
   * @returns standing orders
   */


  getStandingOrders(offset, limit, keyLevel) {
    return Util.callAsync(this.getStandingOrders, async () => {
      const res = await this.accountMember._client.getStandingOrders(this.account.id, offset, limit, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return {
            transactions: res.data.standingOrders || [],
            offset: res.data.offset
          };

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Standing order step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }

}

/**
 * Represents a Token member.
 */
class Member {
  constructor(options) {
    const {
      memberId
    } = options;
    this._id = memberId;
    this._options = options;
  }
  /**
   * Gets the member ID.
   *
   * @return the member ID
   */


  memberId() {
    return this._id;
  }
  /**
   * Gets the member's last hash.
   *
   * @return the hash of the member object
   */


  lastHash() {
    return Util.callAsync(this.lastHash, async () => {
      const member = await this._getMember();
      return member.lastHash;
    });
  }
  /**
   * Gets all of the member's aliases.
   *
   * @return the member's aliases
   */


  aliases() {
    return Util.callAsync(this.aliases, async () => {
      const res = await this._client.getAliases();
      return res.data.aliases || [];
    });
  }
  /**
   * Gets the member's first alias.
   *
   * @return the member's first alias
   */


  firstAlias() {
    return Util.callAsync(this.firstAlias, async () => {
      const res = await this._client.getAliases();
      return res.data.aliases && res.data.aliases[0];
    });
  }
  /**
   * Gets the member's public keys.
   *
   * @return keys objects
   */


  keys() {
    return Util.callAsync(this.keys, async () => {
      const member = await this._getMember();
      return member.keys || [];
    });
  }
  /**
   * Sets the security metadata to be sent with each request.
   *
   * @param securityMetadata
   */


  setSecurityMetadata(securityMetadata) {
    return Util.callSync(this.setSecurityMetadata, () => {
      this._client.setSecurityMetadata(securityMetadata);
    });
  }
  /**
   * Clears the security metadata.
   */


  clearSecurityMetadata() {
    return Util.callSync(this.clearSecurityMetadata, () => {
      this._client.clearSecurityMetadata();
    });
  }
  /**
   * Approves a new key for this member.
   *
   * @param key - key to add
   * @return empty promise
   */


  approveKey(key) {
    return Util.callAsync(this.approveKey, async () => {
      const prevHash = await this.lastHash();
      await this._client.approveKey(prevHash, key);
    });
  }
  /**
   * Approves new keys for this member.
   *
   * @param keys - keys to add
   * @return empty promise
   */


  approveKeys(keys) {
    return Util.callAsync(this.approveKeys, async () => {
      const prevHash = await this.lastHash();
      await this._client.approveKeys(prevHash, keys);
    });
  }
  /**
   * Removes a key from this member.
   *
   * @param keyId - keyId to remove. Note, keyId is the hash of the pk
   * @return empty promise
   */


  removeKey(keyId) {
    return Util.callAsync(this.removeKey, async () => {
      const prevHash = await this.lastHash();
      await this._client.removeKey(prevHash, keyId);
    });
  }
  /**
   * Removes keys from this member.
   *
   * @param keyIds - keyIds to remove. Note, keyId is the hash of the pk
   * @return empty promise
   */


  removeKeys(keyIds) {
    return Util.callAsync(this.removeKeys, async () => {
      const prevHash = await this.lastHash();
      await this._client.removeKeys(prevHash, keyIds);
    });
  }
  /**
   * Adds an alias to this member.
   *
   * @param alias - alias to add
   * @return empty promise
   */


  addAlias(alias) {
    return this.addAliases([alias]);
  }
  /**
   * Adds aliases to this member.
   *
   * @param aliases - aliases to add
   * @return empty promise
   */


  addAliases(aliases) {
    return Util.callAsync(this.addAliases, async () => {
      const member = await this._getMember();
      const normalized = await _Promise.all(aliases.map(alias => this._normalizeAlias(alias, member.partnerId)));
      const prevHash = await this.lastHash();
      await this._client.addAliases(prevHash, normalized);
    });
  }
  /**
   * Removes an alias from the member.
   *
   * @param alias - alias to remove
   * @return empty promise
   */


  removeAlias(alias) {
    return Util.callAsync(this.removeAlias, async () => {
      const prevHash = await this.lastHash();
      await this._client.removeAlias(prevHash, alias);
    });
  }
  /**
   * Removes aliases from the member.
   *
   * @param aliases - aliases to remove
   * @return empty promise
   */


  removeAliases(aliases) {
    return Util.callAsync(this.removeAliases, async () => {
      const prevHash = await this.lastHash();
      await this._client.removeAliases(prevHash, aliases);
    });
  }
  /**
   * Set the 'normal consumer' rule as member's recovery rule.
   * (As of Nov 2017, this rule was: To recover, verify an alias.)
   *
   * @return promise containing RecoveryRule proto buffer.
   */


  useDefaultRecoveryRule() {
    return Util.callAsync(this.useDefaultRecoveryRule, async () => {
      const agentResponse = await this._client.getDefaultRecoveryAgent();
      const prevHash = await this.lastHash();
      const rule = {
        recoveryRule: {
          primaryAgent: agentResponse.data.memberId
        }
      };
      const res = await this._client.addRecoveryRule(prevHash, rule);
      return res.data.member.recoveryRule;
    });
  }
  /**
   * Gets the info of a bank, including a link for pairing accounts at this bank.
   *
   * @param bankId - ID of the bank
   * @return info
   */


  getBankInfo(bankId) {
    return Util.callAsync(this.getBankInfo, async () => {
      const res = await this._client.getBankInfo(bankId);
      return res.data.info;
    });
  }
  /**
   * Looks up the balance of an account.
   *
   * @param accountId - ID of the account
   * @param keyLevel - key level
   * @return Promise of get balance response object
   */


  getBalance(accountId, keyLevel) {
    return Util.callAsync(this.getBalance, async () => {
      const res = await this._client.getBalance(accountId, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.balance;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Balance step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up the balances of an array of accounts.
   *
   * @param accountIds - array of account IDs
   * @param keyLevel - key level
   * @return Promise of get balances response object
   */


  getBalances(accountIds, keyLevel) {
    return Util.callAsync(this.getBalances, async () => {
      const res = await this._client.getBalances(accountIds, keyLevel);
      return res.data.response && res.data.response.map(b => {
        switch (b.status) {
          case 'SUCCESSFUL_REQUEST':
            return b.balance;

          case 'MORE_SIGNATURES_NEEDED':
            throw new Error('Balance step up required');

          default:
            throw new Error(b.status);
        }
      });
    });
  }
  /**
   * Looks up a transaction.
   *
   * @param accountId - ID of the account
   * @param transactionId - which transaction to look up
   * @param keyLevel - key level
   * @return the Transaction
   */


  getTransaction(accountId, transactionId, keyLevel) {
    return Util.callAsync(this.getTransaction, async () => {
      const res = await this._client.getTransaction(accountId, transactionId, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.transaction;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Transaction step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up all of the member's transactions for an account.
   *
   * @param accountId - ID of the account
   * @param offset - where to start looking
   * @param limit - how many to retrieve
   * @param keyLevel - key level
   * @return Transactions
   */


  getTransactions(accountId, offset, limit, keyLevel, startDate, endDate) {
    return Util.callAsync(this.getTransactions, async () => {
      const res = await this._client.getTransactions(accountId, offset, limit, keyLevel, startDate, endDate);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return {
            transactions: res.data.transactions || [],
            offset: res.data.offset
          };

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Transactions step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Confirms if an account has sufficient funds for a purchase.
   *
   * @param accountId
   * @param amount
   * @param currency
   * @return true if account has sufficient funds
   */


  confirmFunds(accountId, amount, currency) {
    return Util.callAsync(this.confirmFunds, async () => {
      const res = await this._client.confirmFunds(accountId, amount, currency);
      return res.data.fundsAvailable;
    });
  }
  /**
   * Signs a token payload with specified level of keys.
   *
   * @param tokenPayload
   * @param keyLevel
   * @returns the proto signature
   */


  signTokenPayload(tokenPayload, keyLevel) {
    return Util.callAsync(this.signTokenPayload, async () => {
      return await this._client.tokenOperationSignature(tokenPayload, 'endorsed', keyLevel);
    });
  }
  /**
   * Deletes the member.
   *
   * @return response to the api call
   */


  deleteMember() {
    return Util.callAsync(this.deleteMember, async () => {
      await this._client.deleteMember();
    });
  }
  /**
   * Resolves transfer destinations for the given account ID.
   *
   * @param accountId - ID of account to resolve destinations for
   * @return resolved transfer destinations
   */


  resolveTransferDestinations(accountId) {
    return Util.callAsync(this.resolveTransferDestinations, async () => {
      const res = await this._client.resolveTransferDestinations(accountId);
      return res.transferDestinations;
    });
  }
  /**
   * Creates a test bank account in a fake bank
   *
   * @param balance - balance of the account
   * @param currency - currency of the account
   * @return bank authorization to use with linkAccounts
   */


  createTestBankAccount(balance, currency) {
    return Util.callAsync(this.createTestBankAccount, async () => {
      const res = await this._client.createTestBankAccount(balance, currency);
      return res.data.authorization;
    });
  }
  /**
   * Creates a test bank account in a fake bank and link it
   *
   * @param balance - balance of the account
   * @param currency - currency of the account
   * @return bank authorization to use with linkAccounts
   */


  createAndLinkTestBankAccount(balance, currency) {
    return Util.callAsync(this.createTestBankAccount, async () => {
      const res = await this._client.createTestBankAccount(balance, currency);
      const res2 = await this._client.linkAccountsOauth(res.data.authorization);
      return res2.data.accounts && new Account(res2.data.accounts[0], this);
    });
  }
  /**
   * Gets test bank notification.
   *
   * @param subscriberId - ID of subscriber
   * @param notificationId - ID of notification
   * @return response to the API call
   */


  getTestBankNotification(subscriberId, notificationId) {
    return Util.callAsync(this.getTestBankNotification, async () => {
      const res = await this._client.getTestBankNotification(subscriberId, notificationId);
      return res.data.notification;
    });
  }
  /**
   * Gets test bank notifications.
   *
   * @param subscriberId - ID of subscriber
   * @return response to the API call
   */


  getTestBankNotifications(subscriberId) {
    return Util.callAsync(this.getTestBankNotifications, async () => {
      const res = await this._client.getTestBankNotifications(subscriberId);
      return res.data.notifications || [];
    });
  }
  /**
   * Looks up an existing standing order for a given account.
   *
   * @param accountId
   * @param standingOrderId
   * @param keyLevel
   * @returns standing order
   */


  getStandingOrder(accountId, standingOrderId, keyLevel) {
    return Util.callAsync(this.getStandingOrder, async () => {
      const res = await this._client.getStandingOrder(accountId, standingOrderId, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return res.data.standingOrder;

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Standing order step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }
  /**
   * Looks up standing orders for a given account.
   *
   * @param accountId
   * @param offset
   * @param limit
   * @param keyLevel
   * @returns standing orders
   */


  getStandingOrders(accountId, offset, limit, keyLevel) {
    return Util.callAsync(this.getStandingOrders, async () => {
      const res = await this._client.getStandingOrders(accountId, offset, limit, keyLevel);

      switch (res.data.status) {
        case 'SUCCESSFUL_REQUEST':
          return {
            standingOrders: res.data.standingOrders || [],
            offset: res.data.offset
          };

        case 'MORE_SIGNATURES_NEEDED':
          throw new Error('Standing order step up required');

        default:
          throw new Error(res.data.status);
      }
    });
  }

  _getMember() {
    return Util.callAsync(this._getMember, async () => {
      const res = await this._unauthenticatedClient.getMember(this._id);
      return res.data.member;
    });
  }

  _normalizeAlias(alias, partnerId) {
    return Util.callAsync(this._normalizeAlias, async () => {
      const normalized = (await this._unauthenticatedClient.normalizeAlias(alias)).data.alias;

      if (partnerId && partnerId !== 'token') {
        // Realm must equal member's partner ID if affiliated
        if (normalized.realm && normalized.realm !== partnerId) {
          throw new Error('Alias realm must equal partner ID: ' + partnerId);
        }

        normalized.realm = partnerId;
      }

      if (alias.realmId) {
        normalized.realmId = alias.realmId;
      }

      return normalized;
    });
  }

}

var signatureScheme$1 = "Token-Ed25519-SHA512";
var urls$1 = {
	local: "http://localhost:8000",
	dev: "https://api.dev.token.io",
	stg: "https://api.stg.token.io",
	perf: "https://api.perf.token.io",
	sandbox: "https://api.sandbox.token.io",
	int: "https://api.int.token.io",
	prd: "https://api.token.io"
};
var webAppUrls$1 = {
	local: "http://localhost:5000",
	dev: "https://web-app.dev.token.io",
	stg: "https://web-app.stg.token.io",
	perf: "https://web-app.perf.token.io",
	sandbox: "https://web-app.sandbox.token.io",
	int: "https://web-app.int.token.io",
	prd: "https://web-app.token.io"
};
var transferTokenVersion$1 = "1.0";
var accessTokenVersion$1 = "1.0";
var defaultCurrency$1 = "EUR";
var decimalPrecision$1 = 4;
var corsDomainSuffix$1 = ".token.io";
var KeyLevel$1 = {
	PRIVILEGED: "PRIVILEGED",
	STANDARD: "STANDARD",
	LOW: "LOW"
};
var lowKeyExpiration$1 = 1209600000;
var devKey$1 = {
	local: "f3982819-5d8d-4123-9601-886df2780f42",
	dev: "f3982819-5d8d-4123-9601-886df2780f42",
	stg: "f3982819-5d8d-4123-9601-886df2780f42",
	perf: "f3982819-5d8d-4123-9601-886df2780f42",
	sandbox: "f3982819-5d8d-4123-9601-886df2780f42",
	int: "f3982819-5d8d-4123-9601-886df2780f42",
	prd: "f3982819-5d8d-4123-9601-886df2780f42"
};
var config$1 = {
	signatureScheme: signatureScheme$1,
	urls: urls$1,
	webAppUrls: webAppUrls$1,
	transferTokenVersion: transferTokenVersion$1,
	accessTokenVersion: accessTokenVersion$1,
	defaultCurrency: defaultCurrency$1,
	decimalPrecision: decimalPrecision$1,
	corsDomainSuffix: corsDomainSuffix$1,
	KeyLevel: KeyLevel$1,
	lowKeyExpiration: lowKeyExpiration$1,
	devKey: devKey$1
};

/**
 * Client for making unauthenticated requests to the Token gateway.
 */

class HttpClient$1 extends HttpClient {
  constructor(options) {
    super(options);
  }
  /**
   * Retrieves a request for a token. Called by the web(user) or by a TPP, to get request details.
   *
   * @param {string} requestId - token request ID
   * @return {Promise} response to the API call
   */


  async retrieveTokenRequest(requestId) {
    const request = {
      method: 'get',
      url: `/token-requests/${requestId}`
    };
    return this._instance(request);
  }
  /**
   * Get the token request result based on its token request ID.
   *
   * @param {string} tokenRequestId - token request ID
   * @return {Object} response to the API call
   */


  async getTokenRequestResult(tokenRequestId) {
    const request = {
      method: 'get',
      url: `/token-requests/${tokenRequestId}/token_request_result`
    };
    return this._instance(request);
  }

}

/**
 * Represents the part of a Token member that can be accessed through an access token.
 */
class Representable {
  /**
   * User Member::forAccessToken.
   */
  constructor(member) {
    this._member = member;
  }
  /**
   * Looks up an account by the account ID.
   *
   * @param accountId - the ID
   * @return Promise resolving to the account
   */


  getAccount(accountId) {
    return this._member.getAccount(accountId);
  }
  /**
   * Looks up linked accounts.
   *
   * @return Promise resolving to the accounts
   */


  getAccounts() {
    return this._member.getAccounts();
  }
  /**
   * Looks up the balance of an account.
   *
   * @param accountId - ID of the account
   * @param keyLevel - key level
   * @return Promise of get balance response object
   */


  getBalance(accountId, keyLevel) {
    return this._member.getBalance(accountId, keyLevel);
  }
  /**
   * Looks up the balances of an array of accounts.
   *
   * @param accountIds - array of account IDs
   * @param keyLevel - key level
   * @return Promise of get balances response object
   */


  getBalances(accountIds, keyLevel) {
    return this._member.getBalances(accountIds, keyLevel);
  }
  /**
   * Looks up an existing transaction for a given account.
   *
   * @param accountId - ID of the account
   * @param transactionId - which transaction to look up
   * @param keyLevel - key level
   * @return Transaction
   */


  getTransaction(accountId, transactionId, keyLevel) {
    return this._member.getTransaction(accountId, transactionId, keyLevel);
  }
  /**
   * Looks up transactions for a given account.
   *
   * @param accountId - ID of the account
   * @param offset - where to start looking
   * @param limit - how many to retrieve
   * @param keyLevel - key level
   * @return Transactions
   */


  getTransactions(accountId, offset, limit, keyLevel, startDate, endDate) {
    return this._member.getTransactions(accountId, offset, limit, keyLevel, startDate, endDate);
  }
  /**
   * Confirms if an account has sufficient funds for a purchase.
   *
   * @param accountId
   * @param amount
   * @param currency
   * @return true if account has sufficient funds
   */


  confirmFunds(accountId, amount, currency) {
    return this._member.confirmFunds(accountId, amount, currency);
  }
  /**
   * Looks up an existing standing order for a given account.
   *
   * @param accountId
   * @param standingOrderId
   * @param keyLevel
   * @returns standing order
   */


  getStandingOrder(accountId, standingOrderId, keyLevel) {
    return this._member.getStandingOrder(accountId, standingOrderId, keyLevel);
  }
  /**
   * Looks up standing orders for a given account.
   *
   * @param accountId
   * @param offset
   * @param limit
   * @param keyLevel
   * @returns standing orders
   */


  getStandingOrders(accountId, offset, limit, keyLevel) {
    return this._member.getStandingOrders(accountId, offset, limit, keyLevel);
  }
  /**
   * Resolves transfer destinations for the given account ID.
   *
   * @param accountId - ID of account to resolve destinations for
   * @return resolved transfer destinations
   */


  resolveTransferDestinations(accountId) {
    return this._member.resolveTransferDestinations(accountId);
  }

}

class Util$1 extends Util {}

function ownKeys$3(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
class TokenRequestBuilder {
  /**
   * Use TokenClient::createTransferTokenRequest or TokenClient::createAccessTokenRequest.
   */
  constructor(payload) {
    this.requestPayload = _objectSpread$3({
      refId: Util$1.generateNonce(),
      to: {},
      callbackState: {}
    }, payload);
    this.requestOptions = {
      from: {}
    };
  }
  /**
   * Sets a custom reference ID on the TokenRequestBuilder.
   * @param refId
   * @return TokenRequestBuilder
   */


  setRefId(refId) {
    this.requestPayload.refId = refId;
    return this;
  }
  /**
   * Sets a default bank ID for the TokenRequestBuilder.
   *
   * @param bankId - the default bank ID
   * @return TokenRequestBuilder
   */


  setBankId(bankId) {
    this.requestOptions.bankId = bankId;
    return this;
  }
  /**
   * Sets the member ID of the payer/grantor.
   *
   * @param fromMemberId - member ID of the payer/grantor
   * @return TokenRequestBuilder
   */


  setFromMemberId(fromMemberId) {
    this.requestOptions.from.id = fromMemberId;
    return this;
  }
  /**
   * Sets the alias of the payer/grantor.
   *
   * @param alias - alias object, or type of alias as a string
   * @param value - optional value of the alias if first param is type
   * @return TokenRequestBuilder
   */


  setFromAlias(alias, value) {
    if (typeof alias === 'string') this.requestOptions.from.alias = {
      type: alias,
      value
    };else this.requestOptions.from.alias = alias;
    return this;
  }
  /**
   * Sets the member ID of the payee/grantee.
   *
   * @param toMemberId - member ID of the payee/grantee
   * @return TokenRequestBuilder
   */


  setToMemberId(toMemberId) {
    this.requestPayload.to.id = toMemberId;
    return this;
  }
  /**
   * Sets the alias of the payee/grantee.
   *
   * @param alias - alias of the payee/grantee
   * @param value - optional value of the alias if first param is type
   * @return TokenRequestBuilder
   */


  setToAlias(alias, value) {
    if (typeof alias === 'string') this.requestPayload.to.alias = {
      type: alias,
      value
    };else this.requestPayload.to.alias = alias;
    return this;
  }
  /**
   * Sets the source account ID.
   *
   * @param accountId - source account ID
   * @return TokenRequestBuilder
   */


  setSourceAccount(accountId) {
    this.requestOptions.sourceAccountId = accountId;
    return this;
  }
  /**
   * Sets if a receipt should be sent to the payee/grantee's default receipt email/SMS/etc.
   *
   * @param receiptRequested - true if a receipt is requested
   * @return TokenRequestBuilder
   */


  setReceiptRequested(receiptRequested) {
    this.requestOptions.receiptRequested = receiptRequested;
    return this;
  }
  /**
   * Sets customization ID for the TokenRequestBuilder.
   *
   * @param customizationId - result of Member::createCustomization
   * @return TokenRequestBuilder
   */


  setCustomizationId(customizationId) {
    this.requestPayload.customizationId = customizationId;
    return this;
  }
  /**
   * Sets acting as on the token.
   *
   * @param actingAs - entity the TPP is acting on behalf of
   * @return TokenRequestBuilder
   */


  setActingAs(actingAs) {
    this.requestPayload.actingAs = actingAs;
    return this;
  }
  /**
   * Sets the description of the token.
   *
   * @param description
   * @return TokenRequestBuilder
   */


  setDescription(description) {
    this.requestPayload.description = description;
    return this;
  }
  /**
   * Sets the callback state.
   *
   * @param state - arbitrary JS object or string
   * @return TokenRequestBuilder
   */


  setCallbackState(state) {
    this.requestPayload.callbackState.innerState = state;
    return this;
  }
  /**
   * Sets the CSRF token.
   *
   * @param csrf - CSRF token
   * @return TokenRequestBuilder
   */


  setCSRFToken(csrf) {
    this.requestPayload.callbackState.csrfTokenHash = Util$1.hashString(csrf);
    return this;
  }
  /**
   * Sets the ID used to track a member claimed by a TPP.
   *
   * @param userRefId
   * @return TokenRequestBuilder
   */


  setUserRefId(userRefId) {
    this.requestPayload.userRefId = userRefId;
    return this;
  }
  /**
   * Sets the callback URL to the server that will initiate redemption of the token.
   *
   * @param redirectUrl
   * @return TokenRequestBuilder
   */


  setRedirectUrl(redirectUrl) {
    this.requestPayload.redirectUrl = redirectUrl;
    return this;
  }

}

/**
 * Client for making authenticated requests to the Token gateway.
 */

class AuthHttpClient$1 extends AuthHttpClient {
  constructor(options) {
    super(options);
  }
  /**
   * Uses the given access token.
   *
   * @param {string} accessTokenId - Id of the access token
   * @param {boolean} customerInitiated - whether the user initiated this session / request
   */


  useAccessToken(accessTokenId, customerInitiated = false) {
    this._context.customerInitiated = customerInitiated;
    this._context.onBehalfOf = accessTokenId;

    this._resetRequestInterceptor();
  }
  /**
   * Replaces the authenticated member's public profile.
   *
   * @param {Object} profile - profile to set
   * @return {Object} response to the API call
   */


  async setProfile(profile) {
    const req = {
      profile
    };
    const request = {
      method: 'put',
      url: '/profile',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Gets a member's public profile.
   *
   * @param {string} id - member ID whose profile to get
   * @return {Object} response to the API call
   */


  async getProfile(id) {
    const request = {
      method: 'get',
      url: `/members/${id}/profile`
    };
    return this._instance(request);
  }
  /**
   * Uploads member's public profile picture.
   *
   * @param {string} type - MIME type
   * @param {Buffer} data - data in bytes
   * @return {Object} response to the API call
   */


  async setProfilePicture(type, data) {
    if (typeof data !== 'string') data = base64js.fromByteArray(data);
    const req = {
      payload: {
        ownerId: this._memberId,
        type: type,
        name: 'profile',
        data,
        accessMode: 'PUBLIC'
      }
    };
    const request = {
      method: 'put',
      url: '/profilepicture',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Gets a member's public profile picture.
   *
   * @param {string} id - member ID whose picture to get
   * @param {Object} size - desired size category: SMALL/MEDIUM/LARGE/ORIGINAL
   * @return {Object} response to the API call
   */


  async getProfilePicture(id, size) {
    const request = {
      method: 'get',
      url: `/members/${id}/profilepicture/${size}`
    };
    return this._instance(request);
  }
  /**
   * Gets a blob from the server.
   *
   * @param {string} blobId - ID of the blob
   * @return {Object} response to the API call
   */


  async getBlob(blobId) {
    const request = {
      method: 'get',
      url: `/blobs/${blobId}`
    };
    return this._instance(request);
  }
  /**
   * Stores a request for a token. Called by a merchant or a TPP that wants access from a user.
   *
   * @param {Object} tokenRequest - token request to store
   * @return {Promise} response to the API call
   */


  async storeTokenRequest(tokenRequest) {
    const request = {
      method: 'post',
      url: '/token-requests',
      data: tokenRequest
    };
    return this._instance(request);
  }
  /**
   * Sets destination account for once if it has'nt been set.
   *
   * @param {string} tokenRequestId - tokenRequestId
   * @param {Array} transferDestinations - transferDestinations
   * @return {Promise} response to the API call
   */


  async setTokenRequestTransferDestinations(tokenRequestId, transferDestinations) {
    const req = {
      tokenRequestId,
      transferDestinations
    };
    const request = {
      method: 'put',
      url: `/token-requests/${tokenRequestId}/transfer-destinations`,
      data: req
    };
    return this._instance(request);
  }
  /**
   * Creates customization.
   *
   * @param {Object} logo - logo
   * @param {Object} colors - colors map of ARGB colors #AARRGGBB
   * @param {string} consentText - consent text
   * @param {string} name - display name
   * @param {string} appName - corresponding app name
   * @return {Promise} response to the API call
   */


  async createCustomization(logo, colors, consentText, name, appName) {
    let imageData = logo.data;
    if (typeof imageData !== 'string') imageData = base64js.fromByteArray(imageData);
    const logoPayload = {
      type: logo.type,
      data: imageData,
      ownerId: logo.ownerId,
      name: logo.name,
      accessMode: logo.accessMode
    };
    const request = {
      method: 'post',
      url: '/customization',
      data: {
        logo: logoPayload,
        colors,
        consentText,
        name,
        appName
      }
    };
    return this._instance(request);
  }
  /**
   * Cancels a token.
   *
   * @param {Object} token - token to cancel
   * @return {Object} response to the API call
   */


  async cancelToken(token) {
    return this._tokenOperation(token, 'cancel', 'cancelled');
  }
  /**
   * Redeems a transfer token.
   *
   * @param {Object} transferToken - token to redeem
   * @param {Number} amount - amount to charge
   * @param {string} currency - currency to charge
   * @param {string} description - description of the transfer
   * @param {Array} destinations - destinations money should go to
   * @param {string} refId - reference ID to attach to the transfer
   * @return {Object} response to the API call
   */


  async redeemToken(transferToken, amount, currency, description, destinations, refId) {
    const payload = {
      refId: refId,
      tokenId: transferToken.id,
      amount: {
        value: amount.toString(),
        currency
      }
    };

    if (description) {
      payload.description = description;
    }

    if (destinations !== undefined && destinations.length > 0) {
      if (destinations[0].account !== undefined) {
        // for backwards compatibility
        payload.destinations = destinations;
      } else {
        payload.transferDestinations = destinations;
      }
    }

    const signer = await this.getSigner(config$1.KeyLevel.LOW);
    const req = {
      payload,
      payloadSignature: {
        memberId: this._memberId,
        keyId: signer.getKeyId(),
        signature: await signer.signJson(payload)
      }
    };
    const request = {
      method: 'post',
      url: '/transfers',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Redeems a standing order token.
   *
   * @param {Object} tokenId - tokenId to redeem
   * @return {Object} response to the API call
   */


  async redeemStandingOrderToken(tokenId) {
    const req = {
      tokenId
    };
    const request = {
      method: 'post',
      url: '/standing-order-submissions',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Gets a token by its ID.
   *
   * @param {string} tokenId - ID of the token to get
   * @return {Object} response to the API call
   */


  async getToken(tokenId) {
    const request = {
      method: 'get',
      url: `/tokens/${tokenId}`
    };
    return this._instance(request);
  }
  /**
   * Gets all tokens of the member, of a certain type.
   *
   * @param {string} type - type of tokens to get
   * @param {string} offset - where to start looking
   * @param {Number} limit - how many to get
   * @return {Object} response to the API call
   */


  async getTokens(type, offset, limit) {
    const request = {
      method: 'get',
      url: `/tokens?type=${type}&offset=${offset}&limit=${limit}`
    };
    return this._instance(request);
  }
  /**
   * Gets a transfer by ID.
   *
   * @param {string} transferId - ID of the transfer
   * @return {Object} response to the API call
   */


  async getTransfer(transferId) {
    const request = {
      method: 'get',
      url: `/transfers/${transferId}`
    };
    return this._instance(request);
  }
  /**
   * Gets all transfers on a token.
   *
   * @param {string} tokenId - ID of the token
   * @param {string} offset - where to start
   * @param {Number} limit - how many to get
   * @return {Object} response to the API call
   */


  async getTransfers(tokenId, offset, limit) {
    const request = {
      method: 'get',
      url: `/transfers?tokenId=${tokenId}&offset=${offset}&limit=${limit}`
    };
    return this._instance(request);
  }
  /**
   * Gets information about one standing order submission.
   *
   * @param {string} submissionId - ID of the transfer
   * @return {Object} response to the API call
   */


  async getStandingOrderSubmission(submissionId) {
    const request = {
      method: 'get',
      url: `/standing-order-submissions/${submissionId}`
    };
    return this._instance(request);
  }
  /**
  * Verifies eIDAS certificate.
  *
  * @param payload payload containing member id, eIDAS alias and the certificate
  * @param signature payload signed with the private key corresponding to the certificate
  * @return result of the verification operation, returned by the server
  */


  async verifyEidas(payload, signature) {
    const req = {
      payload,
      signature
    };
    const request = {
      method: 'post',
      url: '/eidas/verifications',
      data: req
    };
    return this._instance(request);
  }
  /**
   * Retrieves an eIDAS verification status by verificationId.
   *
   * @param verificationId verification id
   * @return a status of the verification operation together with the certificate and alias value
   */


  async getEidasVerificationStatus(verificationId) {
    const request = {
      method: 'get',
      url: `/eidas/verifications/${verificationId}`
    };
    return this._instance(request);
  }
  /**
   * Gets a list of the auth'd member's standing order submissions.
   *
   * @param {string} offset - where to start
   * @param {Number} limit - how many to get
   * @return {Object} response to the API call
   */


  async getStandingOrderSubmissions(offset, limit) {
    const request = {
      method: 'get',
      url: `/standing-order-submissions&offset=${offset}&limit=${limit}`
    };
    return this._instance(request);
  }
  /**
   *  Redeem a bulk transfer token, creating a bulk transfer.
   *
   * @param {String} tokenId - token to redeem
   * @return {Object} response to the API call
   */


  async createBulkTransfer(tokenId) {
    const req = {
      tokenId
    };
    const request = {
      method: 'post',
      url: '/bulk-transfers',
      data: req
    };
    return this._instance(request);
  }
  /**
   *  Get information about one bulk transfer.
   *
   * @param {String} bulkTransferId
   * @return {Object} response to the API call
   */


  async getBulkTransfer(bulkTransferId) {
    const request = {
      method: 'get',
      url: `/bulk-transfers/${bulkTransferId}`
    };
    return this._instance(request);
  }
  /**
   * Get url to bank authorization page for a token request.
   *
   * @param bankId {string} Bank Id
   * @param tokenRequestId {string} Token request id
   * @returns {Object} response to the api call
   */


  async getBankAuthUrl(bankId, tokenRequestId) {
    const request = {
      method: 'post',
      url: `/banks/${bankId}/token-requests/${tokenRequestId}`
    };
    return this._instance(request);
  }
  /**
   * Forward the callback from the bank (after user authentication) to Token.
   *
   * @param bankId {string} bank Id
   * @param query {string} HTTP query string
   * @returns {Object} response to the api call
   */


  async onBankAuthCallback(bankId, query) {
    const request = {
      method: 'post',
      url: `/banks/${bankId}/callback?query=${query}`
    };
    return this._instance(request);
  }
  /**
   * Get the raw consent from the bank associated with a token.
   *
   * @param tokenId {string} Token Id
   * @returns {Object} response to the api call
   */


  async getRawConsent(tokenId) {
    const request = {
      method: 'get',
      url: `/tokens/${tokenId}/consent`
    };
    return this._instance(request);
  }

  async _tokenOperation(token, operation, suffix) {
    const tokenId = token.id;
    const request = {
      method: 'put',
      url: `/tokens/${tokenId}/${operation}`,
      data: await this._tokenOperationRequest(token, suffix)
    };
    return this._instance(request);
  }

  async _tokenOperationRequest(token, suffix) {
    return {
      tokenId: token.id,
      signature: await this.tokenOperationSignature(token.payload, suffix, config$1.KeyLevel.STANDARD)
    };
  }

}

/**
 * Represents a Token member.
 */
class Member$1 extends Member {
  constructor(options) {
    super(options);
    this._unauthenticatedClient = new HttpClient$1(options);
    this._client = new AuthHttpClient$1(options);
  }
  /**
   * Looks up a member's account by ID.
   *
   * @param accountId - accountId
   * @return Promise resolving to the account
   */


  getAccount(accountId) {
    return Util$1.callAsync(this.getAccount, async () => {
      const res = await this._client.getAccount(accountId);
      return new Account(res.data.account, this);
    });
  }
  /**
   * Looks up the member's accounts.
   *
   * @return Promise resolving to the accounts
   */


  getAccounts() {
    return Util$1.callAsync(this.getAccounts, async () => {
      const res = await this._client.getAccounts();
      return res.data.accounts && res.data.accounts.map(a => new Account(a, this)) || [];
    });
  }
  /**
   * Creates a representable that acts as another member via an access token.
   *
   * @param accessTokenId - ID of the access token
   * @return new member that acts as another member
   */


  forAccessToken(accessTokenId) {
    return Util$1.callSync(this.forAccessToken, () => {
      const newMember = new Member$1(this._options);

      newMember._client.useAccessToken(accessTokenId);

      newMember._client.setSecurityMetadata(this._client.getSecurityMetadata());

      return new Representable(newMember);
    });
  }
  /**
   * Replaces the authenticated member's public profile.
   *
   * @param profile - profile to set
   * @return newly-set profile
   */


  setProfile(profile) {
    return Util$1.callAsync(this.setProfile, async () => {
      const res = await this._client.setProfile(profile);
      return res.data.profile;
    });
  }
  /**
   * Gets a member's public profile.
   *
   * @param id - member ID whose profile to get
   * @return profile
   */


  getProfile(id) {
    return Util$1.callAsync(this.getProfile, async () => {
      const res = await this._client.getProfile(id);
      return res.data.profile;
    });
  }
  /**
   * Uploads the authenticated member's public profile.
   *
   * @param type - MIME type
   * @param data - data in bytes, can be base64 string
   * @return empty promise
   */


  setProfilePicture(type, data) {
    return Util$1.callAsync(this.setProfilePicture, async () => {
      await this._client.setProfilePicture(type, data);
    });
  }
  /**
   * Gets a member's public profile picture.
   *
   * @param id - member ID whose picture to get
   * @param size - desired size category SMALL/MEDIUM/LARGE/ORIGINAL
   * @return downloaded blob
   */


  getProfilePicture(id, size) {
    return Util$1.callAsync(this.getProfilePicture, async () => {
      const res = await this._client.getProfilePicture(id, size);
      return res.data.blob;
    });
  }
  /**
   * Creates a customization.
   *
   * @param logo - logo
   * @param colors - map of ARGB colors #AARRGGBB
   * @param consentText - consent text
   * @param name - display name
   * @param appName - corresponding app name
   * @return customization ID
   */


  createCustomization(logo, colors, consentText, name, appName) {
    return Util$1.callAsync(this.createCustomization, async () => {
      const res = await this._client.createCustomization(logo, colors, consentText, name, appName);
      return res.data.customizationId;
    });
  }
  /**
   * Stores a request for a token. Called by a merchant or a TPP that wants access from a user.
   *
   * @param tokenRequest - token request to store
   * @return the stored TokenRequestBuilder
   */


  storeTokenRequest(tokenRequest) {
    return Util$1.callAsync(this.storeTokenRequest, async () => {
      tokenRequest.requestPayload.callbackState = encodeURIComponent(_JSON$stringify(tokenRequest.requestPayload.callbackState));
      const res = await this._client.storeTokenRequest(tokenRequest);
      return res.data.tokenRequest;
    });
  }
  /**
   * Looks up a token by its ID.
   *
   * @param tokenId - ID of the token
   * @return token
   */


  getToken(tokenId) {
    return Util$1.callAsync(this.getToken, async () => {
      const res = await this._client.getToken(tokenId);
      return res.data.token;
    });
  }
  /**
   * Looks up all transfer tokens.
   *
   * @param offset - where to start looking
   * @param limit - how many to look for
   * @return returns a list of Transfer Tokens
   */


  getTransferTokens(offset, limit) {
    return Util$1.callAsync(this.getTransferTokens, async () => {
      const res = await this._client.getTokens('TRANSFER', offset, limit);
      return {
        tokens: res.data.tokens || [],
        offset: res.data.offset
      };
    });
  }
  /**
   * Looks up all access tokens.
   *
   * @param offset - where to start looking
   * @param limit - how many to look for
   * @return access tokens - returns a list of access tokens
   */


  getAccessTokens(offset, limit) {
    return Util$1.callAsync(this.getAccessTokens, async () => {
      const res = await this._client.getTokens('ACCESS', offset, limit);
      return {
        tokens: res.data.tokens || [],
        offset: res.data.offset
      };
    });
  }
  /**
   * Cancels a token.
   *
   * @param token - token to cancel, can be tokenId
   * @return cancelled token
   */


  cancelToken(token) {
    return Util$1.callAsync(this.cancelToken, async () => {
      const finalToken = await this._resolveToken(token);
      const cancelled = await this._client.cancelToken(finalToken);

      if (typeof token !== 'string') {
        token.payloadSignatures = cancelled.data.result.token.payloadSignatures;
      }

      return cancelled.data.result;
    });
  }
  /**
   * Redeems a token.
   *
   * @param token - token to redeem. Can also be a tokenId
   * @param amount - amount to redeem
   * @param currency - currency to redeem
   * @param description - optional transfer description
   * @param destinations - transfer destinations
   * @param refId - ID that will be set on created Transfer.
   *                Token uses this to detect duplicates.
   *                Caller might use this to recognize the transfer.
   *                If param empty, transfer will have random refId.
   * @return Transfer created as a result of this redeem call
   */


  redeemToken(token, amount, currency, description, destinations = [], refId) {
    return Util$1.callAsync(this.redeemToken, async () => {
      const finalToken = await this._resolveToken(token);

      if (!amount) {
        amount = finalToken.payload.transfer.lifetimeAmount;
      }

      if (!currency) {
        currency = finalToken.payload.transfer.currency;
      }

      if (!refId) {
        if (amount === finalToken.payload.transfer.lifetimeAmount) {
          refId = finalToken.payload.refId;
        } else {
          refId = Util$1.generateNonce();
        }
      }

      if (!description) {
        description = finalToken.payload.description;
      }

      if (Util$1.countDecimals(amount) > config$1.decimalPrecision) {
        throw new Error(`Number of decimals in amount should be at most ${config$1.decimalPrecision}`);
      }

      const res = await this._client.redeemToken(finalToken, amount, currency, description, destinations, refId);
      return res.data.transfer;
    });
  }
  /**
   * Looks up a transfer.
   *
   * @param transferId - ID to look up
   * @return transfer if found
   */


  getTransfer(transferId) {
    return Util$1.callAsync(this.getTransfer, async () => {
      const res = await this._client.getTransfer(transferId);
      return res.data.transfer;
    });
  }
  /**
   * Looks up all of the member's transfers.
   *
   * @param tokenId - token to use for lookup
   * @param offset - where to start looking
   * @param limit - how many to retrieve
   * @return Transfers
   */


  getTransfers(tokenId, offset, limit) {
    return Util$1.callAsync(this.getTransfers, async () => {
      const res = await this._client.getTransfers(tokenId, offset, limit);
      return {
        transfers: res.data.transfers || [],
        offset: res.data.offset
      };
    });
  }
  /**
   * Redeems a standing order token.
   *
   * @param token - token to redeem. Can also be a tokenId
   * @return standing order submission created as a result of this redeem call
   */


  redeemStandingOrderToken(tokenId) {
    return Util$1.callAsync(this.redeemStandingOrderToken, async () => {
      const res = await this._client.redeemStandingOrderToken(tokenId);

      if (res.data.submission.status === 'FAILED') {
        const error = new Error('FAILED');
        error.authorizationDetails = res.data.authorizationDetails;
        throw error;
      }

      return res.data.submission;
    });
  }
  /**
   * Redeems a bulk transfer token.
   *
   * @param tokenId ID of token to redeem
   * @return bulk transfer record
   */


  redeemBulkTransferToken(tokenId) {
    return Util$1.callAsync(this.redeemBulkTransferToken, async () => {
      const res = await this._client.createBulkTransfer(tokenId);
      return res.data.transfer;
    });
  }
  /**
   * Looks up an existing bulk transfer.
   *
   * @param bulkTransferId
   * @return bulk transfer record
   */


  getBulkTransfer(bulkTransferId) {
    return Util$1.callAsync(this.getBulkTransfer, async () => {
      const res = await this._client.getBulkTransfer(bulkTransferId);
      return res.data.bulkTransfer;
    });
  }
  /**
   * Looks up an existing Token standing order submission.
   *
   * @param submissionId - ID of the standing order submission
   * @return standing order submission
   */


  getStandingOrderSubmission(submissionId) {
    return Util$1.callAsync(this.getStandingOrderSubmission, async () => {
      const res = await this._client.getStandingOrderSubmission(submissionId);
      return res.data.submission;
    });
  }
  /**
   * Looks up existing Token standing order submissions.
   *
   * @param offset - optional where to start looking
   * @param limit - how many to retrieve
   * @return standing order submissions
   */


  getStandingOrderSubmissions(offset, limit) {
    return Util$1.callAsync(this.getStandingOrderSubmissions, async () => {
      const res = await this._client.getStandingOrderSubmissions(offset, limit);
      return {
        submissions: res.data.submissions || [],
        offset: res.data.offset
      };
    });
  }
  /**
   * Sets destination account for once if it hasn't been set.
   *
   * @param tokenRequestId token request Id
   * @param transferDestinations destination account
   * @return observable that completes when request handled
   */


  setTokenRequestTransferDestinations(tokenRequestId, transferDestinations) {
    return Util$1.callAsync(this.setTokenRequestTransferDestinations, async () => {
      return await this._client.setTokenRequestTransferDestinations(tokenRequestId, transferDestinations);
    });
  }
  /**
   * Downloads a blob from the server.
   *
   * @param blobId - ID of the blob
   * @return downloaded blob
   */


  getBlob(blobId) {
    return Util$1.callAsync(this.getBlob, async () => {
      const res = await this._client.getBlob(blobId);
      return res.data.blob;
    });
  }

  _resolveToken(token) {
    return new _Promise(resolve => {
      if (typeof token === 'string') {
        this.getToken(token).then(lookedUp => resolve(lookedUp));
      } else {
        // token is already in JSON representation
        resolve(token);
      }
    });
  }
  /**
   * Verifies eIDAS alias with an eIDAS certificate, containing auth number equal to the value
   * of the alias. Before making this call make sure that:<ul>
   *     <li>The member is under the realm of a bank (the one tpp tries to gain access to)</li>
   *     <li>An eIDAS-type alias with the value equal to auth number of the TPP is added
   *     to the member</li>
   *     <li>The realmId of the alias is equal to the member's realmId</li>
   *</ul>
   *
   * @param payload - payload containing the member id and the base64 encoded eIDAS certificate
   * @param signature - the payload signed with a private key corresponding to the certificate
   * @return a result of the verification process, including verification status and
   *       verificationId that can be used later to retrieve the status of the verification using
   *       getEidasVerificationStatus call.
   */


  verifyEidas(payload, signature) {
    return Util$1.callAsync(this.verifyEidas, async () => {
      const res = await this._client.verifyEidas(payload, signature);
      return res.data;
    });
  }
  /**
   * Retrieves an eIDAS verification status by verificationId.
   *
   * @param verificationId verification id
   * @return a status of the verification operation together with the certificate and alias value
   */


  async getEidasVerificationStatus(verificationId) {
    return Util$1.callAsync(this.getEidasVerificationStatus, async () => {
      const res = await this._client.getEidasVerificationStatus(verificationId);
      return res.data;
    });
  }
  /**
   * Get url to bank authorization page for a token request.
   *
   * @param bankId {string} Bank Id
   * @param tokenRequestId {string} Token Request Id
   * @returns {string} url
   */


  getBankAuthUrl(bankId, tokenRequestId) {
    return Util$1.callAsync(this.getBankAuthUrl, async () => {
      const res = await this._client.getBankAuthUrl(bankId, tokenRequestId);
      return res.data.url;
    });
  }
  /**
   * Forward the callback from the bank (after user authentication) to Token.
   *
   * @param bankId {string} Bank Id
   * @param query {string} HTTP query string
   * @returns {string} token request ID
   */


  onBankAuthCallback(bankId, query) {
    return Util$1.callAsync(this.onBankAuthCallback, async () => {
      const encodedQuery = query && encodeURIComponent(query) || '';
      const res = await this._client.onBankAuthCallback(bankId, encodedQuery);
      return res.data.tokenRequestId;
    });
  }
  /**
   * Get the raw consent from the bank associated with a token.
   *
   * @param tokenId {string} Token Id
   * @returns {string} raw consent
   */


  getRawConsent(tokenId) {
    return Util$1.callAsync(this.getRawConsent, async () => {
      const res = await this._client.getRawConsent(tokenId);
      return res.data.consent;
    });
  }

}

const fs = require('fs');

const path = require('path');

class PromiseFileSystem {
  /**
   * Reads a file from the filesystem (from the given directory)
   *
   * @param {string} filename - file to read
   * @return {Promise} with data
   */
  static readFile(filename) {
    return new _Promise((resolve, reject) => {
      fs.readFile(PromiseFileSystem._getFullFilename(filename), PromiseFileSystem._options, (err, buffer) => {
        if (err) {
          reject(err);
        } else {
          resolve(buffer);
        }
      });
    });
  }

  static writeFile(filename, data) {
    return new _Promise((resolve, reject) => {
      PromiseFileSystem._ensureExists(PromiseFileSystem.dirRoot, err => {
        if (err) {
          reject(err);
        }

        fs.writeFile(PromiseFileSystem._getFullFilename(filename), data, PromiseFileSystem._options, err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    });
  }

  static _ensureExists(path, cb) {
    fs.mkdir(path, err => {
      if (err) {
        if (err.code === 'EEXIST') cb(null); // ignore folder already exists
        else cb(err); // something else went wrong
      } else cb(null); // successfully created folder

    });
  }

  static _getFullFilename(filename) {
    return path.join(PromiseFileSystem.dirRoot, filename);
  }

}

PromiseFileSystem._options = {
  encoding: 'utf-8',
  mode: 0o600
};
PromiseFileSystem.dirRoot = null;

const globals = {
  activeMemberId: ''
};

class UnsecuredFileKeyStore {
  static setDirRoot(dirRoot) {
    PromiseFileSystem.dirRoot = dirRoot;
  }
  /**
   * Store a key pair.
   *
   * @param {string} memberId - ID of member
   * @param {Object} keyPair - key pair
   * @return {Object} stored key pair
   */


  async put(memberId, keyPair) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!keyPair) {
      throw new Error('Don\'t know what key to put');
    }

    if (!keyPair.level) {
      throw new Error('Don\'t know what level to put key');
    }

    if (keyPair.expiresAtMs < _Date$now()) {
      throw new Error(`Key ${keyPair.id} has expired`);
    }

    const member = (await this._loadMember(memberId)) || {};
    member[keyPair.level] = keyPair;
    await this._saveMember(memberId, member);
    UnsecuredFileKeyStore.setActiveMemberId(memberId);
    return keyPair;
  }
  /**
   * Look up a key by memberId and level.
   *
   * @param {string} memberId - ID of member
   * @param {string} level - 'LOW', 'STANDARD', or 'PRIVILEGED'
   * @return {Object} key pair
   */


  async getByLevel(memberId, level) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!level) {
      throw new Error('Don\'t know what key level to get');
    }

    const member = await this._loadMember(memberId);

    if (!member) {
      throw new Error(`Member with id ${memberId} not found`);
    }

    if (!member[level]) {
      throw new Error(`No key with level ${level} found`);
    }

    if (member[level].expiresAtMs < _Date$now()) {
      throw new Error(`Key with level ${level} has expired`);
    }

    UnsecuredFileKeyStore.setActiveMemberId(memberId);
    return member[level];
  }
  /**
   * Look up a key by memberId and keyId.
   *
   * @param {string} memberId - ID of member
   * @param {string} keyId - key ID
   * @return {Object} key pair
   */


  async getById(memberId, keyId) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!keyId) {
      throw new Error('Don\'t know id of key to get');
    }

    const member = await this._loadMember(memberId);

    if (!member) {
      throw new Error(`member ${memberId} not found`);
    }

    for (const level in member) {
      if (Object.prototype.hasOwnProperty.call(member, level)) {
        if (member[level].id === keyId) {
          if (member[level].expiresAtMs < _Date$now()) {
            throw new Error(`Key with id ${member[level].id} has expired`);
          }

          UnsecuredFileKeyStore.setActiveMemberId(memberId);
          return member[level];
        }
      }
    }

    throw new Error(`No key with id ${keyId} found`);
  }
  /**
   * Return list of member's keys.
   *
   * @param {string} memberId - ID of member
   * @return {Object} list of keys
   */


  async listKeys(memberId) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    const member = await this._loadMember(memberId);

    if (!member) {
      if (!member) {
        throw new Error(`member ${memberId} not found`);
      }
    }

    UnsecuredFileKeyStore.setActiveMemberId(memberId);
    const list = [];

    for (const level in member) {
      if (member.hasOwnProperty(level) && !(member[level].expiresAtMs < _Date$now())) {
        list.push(member[level]);
      }
    }

    return list;
  }
  /**
   * Keep track of the ID of the most recently active member.
   *
   * @param {string} memberId - ID of member
   */


  static setActiveMemberId(memberId) {
    globals.activeMemberId = memberId;
  }
  /**
   * Get the ID of the most recently active member.
   *
   * @return {string} ID of member
   */


  static getActiveMemberId() {
    const memberId = globals.activeMemberId;

    if (!memberId) {
      throw new Error('No active memberId on this browser');
    }

    return memberId;
  }
  /**
   * Save a member's keys.
   *
   * @param {string} memberId - member ID
   * @param {Object} member - obj dict of keys { 'LOW': {...}, 'STANDARD': {...}, ... }
   */


  async _saveMember(memberId, member) {
    // instead of { LOW: {...}, ... } we want [ {...}, ... ]
    // convert keys from buffer -> string
    const strKeys = [];

    for (const level in member) {
      if (member.hasOwnProperty(level)) {
        const keyCopy = _extends({}, member[level]);

        if (keyCopy.publicKey) {
          keyCopy.publicKey = Util$1.strKey(keyCopy.publicKey);
        }

        if (keyCopy.privateKey) {
          keyCopy.privateKey = Util$1.strKey(keyCopy.privateKey);
        }

        strKeys.push(keyCopy);
      }
    }

    await PromiseFileSystem.writeFile(memberId.split(':').join('_'), _JSON$stringify({
      keys: strKeys
    }));
  }
  /**
   * Load a member's keys.
   *
   * @param {string} memberId - ID of member
   * @return {Object} object dict level : key {'LOW': {...}, 'STANDARD': {...}, ...}
   */


  async _loadMember(memberId) {
    let data;

    try {
      data = await PromiseFileSystem.readFile(memberId.split(':').join('_'));
    } catch (error) {
      data = '{"keys":[]}';
    }

    const keyList = JSON.parse(data).keys || [];
    const member = {};

    for (let i = 0; i < keyList.length; i++) {
      const key = keyList[i];

      if (key.publicKey) {
        key.publicKey = Util$1.bufferKey(key.publicKey);
      }

      if (key.privateKey) {
        key.privateKey = Util$1.bufferKey(key.privateKey);
      }

      member[key.level] = key;
    }

    return member;
  }

}

/**
 * UnsecuredFileCryptoEngine: Implements the CryptoEngine interface.
 *
 * Crypto engine to handle signatures, verifications, and key storage, in a file. Uses the following
 * schema
 *
 * filename: memberId
 *
 * file contents: {
 *    'keys':[{
 *        'id':'HxxJ-LKfhYVSDMgC', // key ID
 *        'level':'LOW',
 *        'algorithm':'ED25519',
 *        'publicKey':'wHhFB13fbFVwXGkHPToWASQCQ3hJegQQ', // Util.strKey (public key)
 *        'privateKey':'YgnDobEA0HoZvM7YXvJBR1Sd006apRbeEl6BBA' // Util.strKey (secret key)
 *    }],
 * }
 */

const globalKeyStore$2 = new UnsecuredFileKeyStore();
let dirRootSet = null;

class UnsecuredFileCryptoEngine extends KeyStoreCryptoEngine {
  /**
   * Set the dir in which we'll store key-files.
   * When an sdk user calls
   * const Token = new TokenIO({env: 'sandbox', developerKey: devKey, keyDir: './keys'});
   * that calls UnsecuredFileCryptoEngine.setDirRoot('./keys')
   *
   * @param {string} dirRoot - path
   */
  static setDirRoot(dirRoot) {
    UnsecuredFileKeyStore.setDirRoot(dirRoot);
    dirRootSet = dirRoot;
  }
  /**
   * Constructs the engine
   *
   * @param {string} memberId - memberId of the member we want to create the engine for
   */


  constructor(memberId) {
    if (!memberId) {
      throw new Error('Invalid memberId');
    }

    if (!dirRootSet) {
      throw new Error('No valid directory set');
    }

    super(memberId, globalKeyStore$2);
  }
  /**
   * Get ID of 'active' member. (This would make more sense in browser,
   * where we'd use it to keep track of browser-linked member.)
   *
   * @return {string} member ID of active member (or throw if none such);
   */


  static getActiveMemberId() {
    const memberId = UnsecuredFileKeyStore.getActiveMemberId();

    if (!memberId) {
      throw new Error('No active memberId on this browser');
    }

    return memberId;
  }

}

class TransferTokenRequestBuilder extends TokenRequestBuilder {
  /**
   * Use TokenClient::createTransferTokenRequest.
   */
  constructor(payload) {
    super(payload);
  }
  /**
   * Sets the maximum amount per charge on a transfer token request.
   *
   * @param amount
   * @return TransferTokenRequestBuilder
   */


  setChargeAmount(amount) {
    this.requestPayload.transferBody.amount = amount.toString();
    return this;
  }
  /**
   * Adds a transfer destination to a transfer token request.
   *
   * @param destination
   * @return TransferTokenRequestBuilder
   */


  addTransferDestination(destination) {
    if (!this.requestPayload.transferBody.instructions) {
      this.requestPayload.transferBody.instructions = {
        transferDestinations: []
      };
    } else if (!this.requestPayload.transferBody.instructions.transferDestinations) {
      this.requestPayload.transferBody.instructions.transferDestinations = [];
    }

    this.requestPayload.transferBody.instructions.transferDestinations.push(destination);
    return this;
  }
  /**
   * Adds multiple transfer destinations to a transfer token request.
   *
   * @param destinations
   * @return TransferTokenRequestBuilder
   */


  addTransferDestinations(destinations) {
    if (!this.requestPayload.transferBody.instructions) {
      this.requestPayload.transferBody.instructions = {
        transferDestinations: []
      };
    }

    this.requestPayload.transferBody.instructions.transferDestinations.push(...destinations);
    return this;
  }
  /**
   * @deprecated Use addTransferDestination instead.
   *
   * Adds a transfer destination to a transfer token request.
   *
   * @param destination
   * @return TransferTokenRequestBuilder
   */


  addDestination(destination) {
    if (!this.requestPayload.transferBody.destinations) {
      this.requestPayload.transferBody.destinations = [];
    }

    this.requestPayload.transferBody.destinations.push(destination);
    return this;
  }
  /**
   * @deprecated Use addTransferDestinations instead.
   *
   * Adds multiple transfer destinations to a transfer token request.
   *
   * @param destinations
   * @return TransferTokenRequestBuilder
   */


  addDestinations(destinations) {
    if (!this.requestPayload.transferBody.destinations) {
      this.requestPayload.transferBody.destinations = [];
    }

    this.requestPayload.transferBody.destinations.push(...destinations);
    return this;
  }
  /**
   * Sets the destination country in order to narrow down
   * the country selection in the web-app UI.
   *
   * @param destinationCountry
   * @return TransferTokenRequestBuilder
   */


  setDestinationCountry(destinationCountry) {
    this.requestPayload.destinationCountry = destinationCountry;
    return this;
  }
  /**
   * Sets the execution date of the transfer. Used for future-dated payments.
   *
   * @param executionDate execution date
   * @return TransferTokenRequestBuilder
   */


  setExecutionDate(executionDate) {
    this.requestPayload.transferBody.executionDate = executionDate;
    return this;
  }
  /**
   * Adds metadata for a specific provider.
   *
   * @param providerTransferMetadata provider-specific metadata
   * @return TransferTokenRequestBuilder
   */


  setProviderTransferMetadata(providerTransferMetadata) {
    if (!this.requestPayload.transferBody.instructions) {
      this.requestPayload.transferBody.instructions = {};
    }

    if (!this.requestPayload.transferBody.instructions.metadata) {
      this.requestPayload.transferBody.instructions.metadata = {};
    }

    this.requestPayload.transferBody.instructions.metadata.providerTransferMetadata = providerTransferMetadata;
    return this;
  }
  /**
   * Sets whether CAF should be attempted before transfer
   *
   * @param confirmFunds - whether to attempt CAF before transfer
   * @return TransferTokenRequestBuilder
   */


  setConfirmFunds(confirmFunds) {
    this.requestPayload.transferBody.confirmFunds = confirmFunds;
    return this;
  }
  /**
   * Optional. In the scenario where TPP wishes to know the user's selection of country and
   * bank, TPP should provide this url so that Token can make a call with relevant
   * information as parameters. TPP can use that information to set transfer destination.
   *
   * @param url - URL
   * @return TransferTokenRequestBuilder
   */


  setSetTransferDestinationsUrl(url) {
    this.requestPayload.transferBody.setTransferDestinationsUrl = url;
    return this;
  }
  /**
   * Optional. Sets the source account to bypass account selection.
   *
   * @param source
   * @return TransferTokenRequestBuilder
   */


  setSource(source) {
    if (!this.requestPayload.transferBody.instructions) {
      this.requestPayload.transferBody.instructions = {};
    }

    this.requestPayload.transferBody.instructions.source = source;
    return this;
  }

}

class AccessTokenRequestBuilder extends TokenRequestBuilder {
  /**
   * Use TokenClient::createAccessTokenRequest.
   */
  constructor(payload) {
    super(payload);
  }

}

class StandingOrderTokenRequestBuilder extends TokenRequestBuilder {
  /**
   * Use TokenClient::createStandingOrderTokenRequest.
   */
  constructor(payload) {
    super(payload);
  }
  /**
   * Sets the maximum amount per charge on a standing order token request.
   *
   * @param amount
   * @return StandingOrderTokenRequestBuilder
   */


  setChargeAmount(amount) {
    this.requestPayload.standingOrderBody.amount = amount.toString();
    return this;
  }
  /**
   * Sets the currency for each charge in the standing order token request.
   *
   * @param currency
   * @return StandingOrderTokenRequestBuilder
   */


  setCurrency(currency) {
    this.requestPayload.standingOrderBody.currency = currency;
    return this;
  }
  /**
   * Sets the frequency of the standing order token request.
   *
   * @param frequency
   * @return StandingOrderTokenRequestBuilder
   */


  setFrequency(frequency) {
    this.requestPayload.standingOrderBody.frequency = frequency;
    return this;
  }
  /**
   * Sets the start date of the standing order token request. ISO 8601: YYYY-MM-DD or YYYYMMDD.
   *
   * @param startDate
   * @return StandingOrderTokenRequestBuilder
   */


  setStartDate(startDate) {
    this.requestPayload.standingOrderBody.startDate = startDate;
    return this;
  }
  /**
   * Sets the end date of the standing order token request. ISO 8601: YYYY-MM-DD or YYYYMMDD.
   * If not specified, the standing order will occur indefinitely.
   *
   * @param endDate
   * @return StandingOrderTokenRequestBuilder
   */


  setEndDate(endDate) {
    this.requestPayload.standingOrderBody.endDate = endDate;
    return this;
  }
  /**
   * Adds a transfer destination to a standing order token request.
   *
   * @param destination
   * @return StandingOrderTokenRequestBuilder
   */


  addTransferDestination(destination) {
    if (!this.requestPayload.standingOrderBody.instructions) {
      this.requestPayload.standingOrderBody.instructions = {
        transferDestinations: []
      };
    } else if (!this.requestPayload.standingOrderBody.instructions.transferDestinations) {
      this.requestPayload.standingOrderBody.instructions.transferDestinations = [];
    }

    this.requestPayload.standingOrderBody.instructions.transferDestinations.push(destination);
    return this;
  }
  /**
   * Sets the destination country in order to narrow down
   * the country selection in the web-app UI.
   *
   * @param destinationCountry
   * @return StandingOrderTokenRequestBuilder
   */


  setDestinationCountry(destinationCountry) {
    this.requestPayload.destinationCountry = destinationCountry;
    return this;
  }
  /**
   * Sets the meta data for a specific provider
   *
   * @param metadata
   * @return StandingOrderTokenRequestBuilder
   */


  setProviderTransferMetadata(metadata) {
    this.requestPayload.standingOrderBody.instructions.metadata = metadata;
    return this;
  }
  /**
   * Optional. Sets the source account to bypass account selection.
   *
   * @param source
   * @return StandingOrderTokenRequestBuilder
   */


  setSource(source) {
    this.requestPayload.standingOrderBody.instructions = {
      source
    };
    return this;
  }

}

class BulkTransferTokenRequestBuilder extends TokenRequestBuilder {
  /**
   * Use TokenClient::createBulkTransferTokenRequest.
   */
  constructor(payload) {
    super(payload);
  }
  /**
   * Adds a transfer source.
   *
   * @param source
   * @return BulkTransferTokenBuilder
   */


  setSource(source) {
    this.requestPayload.bulkTransferBody.source = source;
    return this;
  }

}

/**
 * Token SDK entry point.
 */

class TokenClient$1 extends TokenClient {
  constructor(options) {
    super(options);
    this.options.keyDir = options.keyDir;
    this._unauthenticatedClient = new HttpClient$1(options);
    this.UnsecuredFileCryptoEngine = UnsecuredFileCryptoEngine;
    options.keyDir && this.UnsecuredFileCryptoEngine.setDirRoot(options.keyDir);
    this.Util = Util$1;
  }
  /**
   * Creates a business member with a alias and a key pair using the provided engine.
   *
   * @param  alias - alias for the member
   * @param  CryptoEngine - engine to use for key creation and storage
   * @param  realmId - (optional) member id of the Member to which this new member will belong
   * @return Promise of created Member
   */


  createMember(alias, CryptoEngine, realmId) {
    return super.createMemberCore(alias, CryptoEngine, Member$1, 'BUSINESS', undefined, realmId);
  }
  /**
   * Returns 'logged-in' member that uses keys already in the CryptoEngine.
   * If memberId is not provided, the last member to 'log in' will be used.
   *
   * @param CryptoEngine - engine to use for key creation and storage
   * @param memberId - optional ID of the member we want to log in
   * @return instantiated member
   */


  getMember(CryptoEngine, memberId) {
    return super.getMemberCore(CryptoEngine, Member$1, memberId);
  }
  /**
   * Creates a TokenRequestBuilder for an access token.
   *
   * @param resources - resources to request access of, either an array of either ResourceType or AccountResourceType
   * @return The created TokenRequestBuilder
   */


  createAccessTokenRequest(resources) {
    return Util$1.callSync(this.createAccessTokenRequest, () => {
      let payload;

      if (typeof resources[0] === 'string') {
        payload = {
          accessBody: {
            type: resources,
            resourceTypeList: {
              resources
            }
          }
        };
      } else {
        payload = {
          accessBody: {
            accountResourceList: {
              resources
            }
          }
        };
      }

      return new AccessTokenRequestBuilder(payload);
    });
  }
  /**
   * Creates a funds confirmation request.
   *
   * @param bankId - bank ID
   * @param account - user's account
   * @param customerData - optional customer data
   * @return The created funds confirmation request builder
   */


  createFundsConfirmationRequest(bankId, account, customerData) {
    return Util$1.callSync(this.createFundsConfirmationRequest, () => {
      const payload = {
        accessBody: {
          accountResourceList: {
            resources: [{
              type: 'ACCOUNT_FUNDS_CONFIRMATION',
              bankAccount: account,
              customerData: customerData
            }]
          }
        }
      };
      return new AccessTokenRequestBuilder(payload).setBankId(bankId);
    });
  }
  /**
   * Creates a TokenRequestBuilder for a transfer token.
   *
   * @param lifetimeAmount - lifetime amount of the token
   * @param currency - 3 letter currency code for the amount, e.g. 'USD'
   * @return The created TokenRequestBuilder
   */


  createTransferTokenRequest(lifetimeAmount, currency) {
    return Util$1.callSync(this.createTransferTokenRequest, () => {
      const payload = {
        transferBody: {
          currency: currency,
          lifetimeAmount: lifetimeAmount.toString()
        }
      };
      return new TransferTokenRequestBuilder(payload);
    });
  }
  /**
   * Creates a StandingOrderTokenRequestBuilder for a standing order submission token.
   *
   * @param amount
   * @param currency
   * @param frequency Sets the frequency of the standing order. ISO 20022: DAIL, WEEK, TOWK,
                      MNTH, TOMN, QUTR, SEMI, YEAR
   * @param startDate ISO 8601: YYYY-MM-DD or YYYYMMDD.
   * @param endDate   ISO 8601: YYYY-MM-DD or YYYYMMDD. If not specified, the standing order will occur indefinitely.
   * @returns The created StandingOrderTokenRequestBuilder
   */


  createStandingOrderTokenRequest(amount, currency, frequency, startDate, endDate) {
    return Util$1.callSync(this.createStandingOrderTokenRequest, () => {
      const payload = {
        standingOrderBody: {
          amount: amount.toString(),
          currency,
          frequency,
          startDate,
          endDate,
          instructions: {
            transferDestinations: [],
            metadata: {}
          }
        }
      };
      return new StandingOrderTokenRequestBuilder(payload);
    });
  }
  /**
   * Creates a createBulkTransferTokenRequestBuilder for a bulk transfer token request.
   *
   * @param transfers List of transfers
   * @param totalAmount Total amount irrespective of currency. Used for redundancy check.
   * @returns Builder instance
   */


  createBulkTransferTokenRequest(transfers, totalAmount) {
    return Util$1.callSync(this.createBulkTransferTokenRequest, () => {
      const payload = {
        bulkTransferBody: {
          transfers,
          totalAmount: totalAmount.toString()
        }
      };
      return new BulkTransferTokenRequestBuilder(payload);
    });
  }
  /**
   * Retrieves a request for a token to get request details.
   *
   * @param requestId - token request ID
   * @return information about the tokenRequest
   */


  retrieveTokenRequest(requestId) {
    return Util$1.callAsync(this.retrieveTokenRequest, async () => {
      const res = await this._unauthenticatedClient.retrieveTokenRequest(requestId);
      return res.data;
    });
  }
  /**
   * Generates a token request authorization URL.
   *
   * @param requestId - request ID
   * @return token request URL
   */


  generateTokenRequestUrl(requestId) {
    return Util$1.callSync(this.generateTokenRequestUrl, () => {
      return `${this.options.customSdkUrl || config$1.webAppUrls[this.options.env]}/app/request-token/${requestId}`; // eslint-disable-line max-len
    });
  }
  /**
   * Parses the Set Transfer Destinations URL callback parameters to extract supported types, bank and country.
   *
   * @param url - setSetTransferDestinations URL
   * @return TokenRequestTransferDestinationsCallbackParameters - Object
   */


  parseSetTransferDestinationsUrl(url) {
    return Util$1.callSync(this.parseSetTransferDestinationsUrl, () => {
      return Util$1.parseParamsFromUrl(url);
    });
  }
  /**
   * Parses a token request callback URL and verifies the state and signature.
   * This is used at the end of the redirect flow before redeeming the token.
   *
   * @param callbackUrl - callback URL
   * @param csrfToken - CSRF token
   * @return inner state and token ID
   */


  parseTokenRequestCallbackUrl(callbackUrl, csrfToken) {
    return Util$1.callAsync(this.parseTokenRequestCallbackUrl, async () => {
      const urlParams = Util$1.parseParamsFromUrl(callbackUrl);
      if (urlParams.error) throw new Error(`Error at bank: ${urlParams.error}`);
      return await this.parseTokenRequestCallbackParams(urlParams, csrfToken);
    });
  }
  /**
   * Parses a token request callback object and verifies the state and signature.
   * This is similar to parseTokenRequestCallbackUrl
   * but used in the popup flow instead of redirect.
   *
   * @param callback
   * @param csrfToken
   */


  parseTokenRequestCallbackParams(callback, csrfToken) {
    return Util$1.callAsync(this.parseTokenRequestCallbackParams, async () => {
      const tokenMember = await this._unauthenticatedClient.getTokenMember();
      const params = {
        tokenId: callback.tokenId,
        state: JSON.parse(decodeURIComponent(callback.state)),
        signature: JSON.parse(callback.signature)
      };

      if (csrfToken && params.state.csrfTokenHash !== Util$1.hashString(csrfToken)) {
        throw new Error('Invalid CSRF token');
      }

      const signingKey = Util$1.getSigningKey(tokenMember.keys, params.signature);
      await this.Crypto.verifyJson({
        state: callback.state,
        tokenId: params.tokenId
      }, params.signature.signature, Util$1.bufferKey(signingKey.publicKey));
      return {
        tokenId: params.tokenId,
        innerState: params.state.innerState
      };
    });
  }
  /**
   * Gets the token request result based on its token request ID.
   *
   * @param tokenRequestId - token request ID
   * @return token ID and signature
   */


  getTokenRequestResult(tokenRequestId) {
    return Util$1.callAsync(this.getTokenRequestResult, async () => {
      const res = await this._unauthenticatedClient.getTokenRequestResult(tokenRequestId);
      return res.data;
    });
  }

}

export { TokenClient$1 as TokenClient };
